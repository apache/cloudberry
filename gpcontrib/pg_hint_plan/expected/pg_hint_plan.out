-- start_matchignore
-- m/^LOG.*statement.*/
-- m/^NOTICE.*SELECT uses system-defined column.*/
-- m/^HINT.*To uniquely identify a row within a distributed table.*/
-- m/.*The 'DISTRIBUTED BY' clause determines the distribution of data*/
-- m/.*Table doesn't have 'DISTRIBUTED BY' clause*/
-- end_matchignore
SET search_path TO public;
set optimizer to off;
SET client_min_messages TO log;
\set SHOW_CONTEXT always
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.val = t2.val;
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.val = t2.val)
         ->  Seq Scan on t1
         ->  Hash
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(8 rows)

LOAD 'pg_hint_plan';
SET pg_hint_plan.debug_print TO on;
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.val = t2.val;
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.val = t2.val)
         ->  Seq Scan on t1
         ->  Hash
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(8 rows)

/*+ Test (t1 t2) */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+ Test (t1 t2) */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
INFO:  pg_hint_plan: hint syntax error at or near "Test (t1 t2) "
DETAIL:  Unrecognized hint keyword "Test".
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

SET pg_hint_plan.enable_hint TO off;
/*+ Test (t1 t2) */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+ Test (t1 t2) */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

SET pg_hint_plan.enable_hint TO on;
LOG:  statement: SET pg_hint_plan.enable_hint TO on;
/*Set(enable_seqscan off)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*Set(enable_seqscan off)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

--+Set(enable_seqscan off)
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+Set(enable_seqscan off) /* nest comment */ */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+Set(enable_seqscan off) /* nest comment */ */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
INFO:  pg_hint_plan: hint syntax error at or near "/* nest comment */ */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;"
DETAIL:  Nested block comments are not supported.
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+Set(enable_seqscan off)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+Set(enable_seqscan off)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
Set(enable_seqscan off)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                    
--------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Index Scan using t2_pkey on t2
 Optimizer: Postgres query optimizer
(8 rows)

EXPLAIN (COSTS false) /*+Set(enable_seqscan off)*/
 SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: EXPLAIN (COSTS false) /*+Set(enable_seqscan off)*/
 SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
Set(enable_seqscan off)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                    
--------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Index Scan using t2_pkey on t2
 Optimizer: Postgres query optimizer
(8 rows)

/*+ Set(enable_seqscan off) Set(enable_hashjoin off) */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+ Set(enable_seqscan off) Set(enable_hashjoin off) */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
Set(enable_hashjoin off)
Set(enable_seqscan off)
not used hint:
duplication hint:
error hint:
                 QUERY PLAN                 
--------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Join
         Merge Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
         ->  Index Scan using t2_pkey on t2
 Optimizer: Postgres query optimizer
(6 rows)

/*+ 	 Set 	 ( 	 enable_seqscan 	 off 	 ) 	 */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+ 	 Set 	 ( 	 enable_seqscan 	 off 	 ) 	 */
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
Set(enable_seqscan off)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                    
--------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Index Scan using t2_pkey on t2
 Optimizer: Postgres query optimizer
(8 rows)

/*+ 	 
	 	Set 	 
	 	( 	 
	 	enable_seqscan 	 
	 	off 	 
	 	) 	 
	 	*/	 	
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+ 	 
	 	Set 	 
	 	( 	 
	 	enable_seqscan 	 
	 	off 	 
	 	) 	 
	 	*/	 	
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
Set(enable_seqscan off)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                    
--------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Index Scan using t2_pkey on t2
 Optimizer: Postgres query optimizer
(8 rows)

/*+ Set(enable_indexscan off)Set(enable_nestloop off)Set(enable_mergejoin off)	 	
	 	Set(enable_seqscan off)
	 	*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+ Set(enable_indexscan off)Set(enable_nestloop off)Set(enable_mergejoin off)	 	
	 	Set(enable_seqscan off)
	 	*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
Set(enable_indexscan off)
Set(enable_mergejoin off)
Set(enable_nestloop off)
Set(enable_seqscan off)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Bitmap Heap Scan on t2
                     ->  Bitmap Index Scan on t2_pkey
 Optimizer: Postgres query optimizer
(9 rows)

/*+Set(work_mem "1M")*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+Set(work_mem "1M")*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
INFO:  invalid value for parameter "work_mem": "1M"
HINT:  Valid units for this parameter are "B", "kB", "MB", "GB", and "TB".
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Set(work_mem 1M)
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+Set(work_mem "1MB")*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+Set(work_mem "1MB")*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
Set(work_mem 1MB)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+Set(work_mem TO "1MB")*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+Set(work_mem TO "1MB")*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
INFO:  pg_hint_plan: hint syntax error at or near "Set(work_mem TO "1MB")"
DETAIL:  Set hint requires name and value of GUC parameter.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Set(work_mem TO 1MB)
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+IndexScan() */ SELECT 1;
INFO:  pg_hint_plan: hint syntax error at or near " "
DETAIL:  IndexScan hint requires a relation.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
IndexScan()
 ?column? 
----------
        1
(1 row)

/*+IndexScan(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+IndexScan(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  available indexes for IndexScan(t1):
LOG:  pg_hint_plan:
used hint:
IndexScan(t1 t2)
not used hint:
duplication hint:
error hint:
                 QUERY PLAN                 
--------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+IndexScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+IndexScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
not used hint:
duplication hint:
error hint:
                 QUERY PLAN                 
--------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+IndexScan(t1)IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+IndexScan(t1)IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
IndexScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                    
--------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
         ->  Hash
               ->  Index Scan using t2_pkey on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Bitmap Heap Scan on t2
                     ->  Bitmap Index Scan on t2_pkey
 Optimizer: Postgres query optimizer
(8 rows)

/*+BitmapScan(t2)NoSeqScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+BitmapScan(t2)NoSeqScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
NoSeqScan(t1)
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Bitmap Heap Scan on t2
                     ->  Bitmap Index Scan on t2_pkey
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoIndexScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+NoIndexScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
NoIndexScan(t1)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+NoBitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t4 WHERE t1.val < 10;
LOG:  statement: /*+NoBitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t4 WHERE t1.val < 10;
LOG:  pg_hint_plan:
used hint:
NoBitmapScan(t1)
not used hint:
duplication hint:
error hint:
                       QUERY PLAN                        
---------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Seq Scan on t4
         ->  Materialize
               ->  Index Scan using t1_val on t1
                     Index Cond: (val < 10)
 Optimizer: Postgres query optimizer
(8 rows)

/*+TidScan(t4)*/
EXPLAIN (COSTS false) SELECT * FROM t3, t4 WHERE t3.id = t4.id AND t4.ctid = '(1,1)';
LOG:  statement: /*+TidScan(t4)*/
EXPLAIN (COSTS false) SELECT * FROM t3, t4 WHERE t3.id = t4.id AND t4.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t4.ctid" without the necessary companion column "t4.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(t4)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t3.id = t4.id)
         ->  Seq Scan on t3
         ->  Hash
               ->  Tid Scan on t4
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(8 rows)

/*+NoTidScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)';
LOG:  statement: /*+NoTidScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoTidScan(t1)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
         ->  Hash
               ->  Seq Scan on t1
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(8 rows)

/*+ NestLoop() */ SELECT 1;
INFO:  pg_hint_plan: hint syntax error at or near " "
DETAIL:  NestLoop hint requires at least two relations.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
NestLoop()
 ?column? 
----------
        1
(1 row)

/*+ NestLoop(x) */ SELECT 1;
INFO:  pg_hint_plan: hint syntax error at or near " "
DETAIL:  NestLoop hint requires at least two relations.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
NestLoop(x)
 ?column? 
----------
        1
(1 row)

/*+HashJoin(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+HashJoin(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
HashJoin(t1 t2)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+NestLoop(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+NestLoop(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
NestLoop(t1 t2)
not used hint:
duplication hint:
error hint:
                 QUERY PLAN                 
--------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Seq Scan on t2
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id = t2.id)
 Optimizer: Postgres query optimizer
(6 rows)

/*+NoMergeJoin(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+NoMergeJoin(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
NoMergeJoin(t1 t2)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+MergeJoin(t1 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t3 WHERE t1.val = t3.val;
LOG:  statement: /*+MergeJoin(t1 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t3 WHERE t1.val = t3.val;
LOG:  pg_hint_plan:
used hint:
MergeJoin(t1 t3)
not used hint:
duplication hint:
error hint:
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Join
         Merge Cond: (t1.val = t3.val)
         ->  Index Scan using t1_val on t1
         ->  Sort
               Sort Key: t3.val
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(9 rows)

/*+NestLoop(t1 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t3 WHERE t1.val = t3.val;
LOG:  statement: /*+NestLoop(t1 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t3 WHERE t1.val = t3.val;
LOG:  pg_hint_plan:
used hint:
NestLoop(t1 t3)
not used hint:
duplication hint:
error hint:
                       QUERY PLAN                        
---------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Seq Scan on t3
         ->  Index Scan using t1_val on t1
               Index Cond: (val = t3.val)
 Optimizer: Postgres query optimizer
(7 rows)

/*+NoHashJoin(t1 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t3 WHERE t1.val = t3.val;
LOG:  statement: /*+NoHashJoin(t1 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t3 WHERE t1.val = t3.val;
LOG:  pg_hint_plan:
used hint:
NoHashJoin(t1 t3)
not used hint:
duplication hint:
error hint:
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Join
         Merge Cond: (t1.val = t3.val)
         ->  Index Scan using t1_val on t1
         ->  Sort
               Sort Key: t3.val
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(9 rows)

/*+MergeJoin(t4 t1 t2 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  statement: /*+MergeJoin(t4 t1 t2 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  pg_hint_plan:
used hint:
MergeJoin(t1 t2 t3 t4)
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Join
         Merge Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
         ->  Sort
               Sort Key: t2.id
               ->  Hash Join
                     Hash Cond: (t2.id = t3.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t3.id = t4.id)
                                 ->  Seq Scan on t3
                                 ->  Hash
                                       ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(16 rows)

/*+HashJoin(t3 t4 t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  statement: /*+HashJoin(t3 t4 t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  pg_hint_plan:
used hint:
HashJoin(t1 t2 t3 t4)
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t3.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t3.id = t4.id)
                                 ->  Seq Scan on t3
                                 ->  Hash
                                       ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(15 rows)

/*+NestLoop(t2 t3 t4 t1) IndexScan(t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  statement: /*+NestLoop(t2 t3 t4 t1) IndexScan(t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  pg_hint_plan:
used hint:
IndexScan(t3)
NestLoop(t1 t2 t3 t4)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Hash Join
               Hash Cond: (t3.id = t2.id)
               ->  Index Scan using t3_pkey on t3
               ->  Hash
                     ->  Hash Join
                           Hash Cond: (t2.id = t4.id)
                           ->  Seq Scan on t2
                           ->  Hash
                                 ->  Seq Scan on t4
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id = t2.id)
 Optimizer: Postgres query optimizer
(14 rows)

/*+NoNestLoop(t4 t1 t3 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  statement: /*+NoNestLoop(t4 t1 t3 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  pg_hint_plan:
used hint:
NoNestLoop(t1 t2 t3 t4)
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t3.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t3.id = t4.id)
                                 ->  Seq Scan on t3
                                 ->  Hash
                                       ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(15 rows)

/*+Leading( */
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  statement: /*+Leading( */
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
INFO:  pg_hint_plan: hint syntax error at or near ""
DETAIL:  Closing parenthesis is necessary.
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t3.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t3.id = t4.id)
                                 ->  Seq Scan on t3
                                 ->  Hash
                                       ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(15 rows)

/*+Leading( )*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  statement: /*+Leading( )*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
INFO:  pg_hint_plan: hint syntax error at or near "Leading( )"
DETAIL:  Leading hint requires at least two relations.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Leading()
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t3.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t3.id = t4.id)
                                 ->  Seq Scan on t3
                                 ->  Hash
                                       ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(15 rows)

/*+Leading( t3 )*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  statement: /*+Leading( t3 )*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
INFO:  pg_hint_plan: hint syntax error at or near "Leading( t3 )"
DETAIL:  Leading hint requires at least two relations.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Leading(t3)
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t3.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t3.id = t4.id)
                                 ->  Seq Scan on t3
                                 ->  Hash
                                       ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(15 rows)

/*+Leading( t3 t4 )*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  statement: /*+Leading( t3 t4 )*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  pg_hint_plan:
used hint:
Leading(t3 t4)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Merge Join
               Merge Cond: (t1.id = t3.id)
               ->  Index Scan using t1_pkey on t1
               ->  Sort
                     Sort Key: t3.id
                     ->  Hash Join
                           Hash Cond: (t3.id = t4.id)
                           ->  Seq Scan on t3
                           ->  Hash
                                 ->  Seq Scan on t4
         ->  Index Scan using t2_pkey on t2
               Index Cond: (id = t1.id)
 Optimizer: Postgres query optimizer
(15 rows)

/*+Leading(t3 t4 t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  statement: /*+Leading(t3 t4 t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  pg_hint_plan:
used hint:
Leading(t3 t4 t1)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Hash Join
               Hash Cond: (t1.id = t3.id)
               ->  Seq Scan on t1
               ->  Hash
                     ->  Hash Join
                           Hash Cond: (t3.id = t4.id)
                           ->  Seq Scan on t3
                           ->  Hash
                                 ->  Seq Scan on t4
         ->  Index Scan using t2_pkey on t2
               Index Cond: (id = t1.id)
 Optimizer: Postgres query optimizer
(14 rows)

/*+Leading(t3 t4 t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  statement: /*+Leading(t3 t4 t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  pg_hint_plan:
used hint:
Leading(t3 t4 t1 t2)
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t1.id = t3.id)
                     ->  Seq Scan on t1
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t3.id = t4.id)
                                 ->  Seq Scan on t3
                                 ->  Hash
                                       ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(15 rows)

/*+Leading(t1 t2 t3 t4)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  statement: /*+Leading(t1 t2 t3 t4)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  pg_hint_plan:
used hint:
Leading(t1 t2 t3 t4)
not used hint:
duplication hint:
error hint:
                   QUERY PLAN                   
------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t4.id)
         ->  Hash Join
               Hash Cond: (t1.id = t3.id)
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Seq Scan on t1
                     ->  Hash
                           ->  Seq Scan on t2
               ->  Hash
                     ->  Seq Scan on t3
         ->  Hash
               ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(15 rows)

/*+Leading(t3 t4 t1 t2 t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  statement: /*+Leading(t3 t4 t1 t2 t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
INFO:  pg_hint_plan: hint syntax error at or near "Leading(t3 t4 t1 t2 t1)"
DETAIL:  Relation name "t1" is duplicated.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Leading(t3 t4 t1 t2 t1)
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t3.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t3.id = t4.id)
                                 ->  Seq Scan on t3
                                 ->  Hash
                                       ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(15 rows)

/*+Leading(t3 t4 t4)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
LOG:  statement: /*+Leading(t3 t4 t4)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id;
INFO:  pg_hint_plan: hint syntax error at or near "Leading(t3 t4 t4)"
DETAIL:  Relation name "t4" is duplicated.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Leading(t3 t4 t4)
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t3.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t3.id = t4.id)
                                 ->  Seq Scan on t3
                                 ->  Hash
                                       ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(15 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, (VALUES(1,1),(2,2),(3,3)) AS t2(id,val) WHERE t1.id = t2.id;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, (VALUES(1,1),(2,2),(3,3)) AS t2(id,val) WHERE t1.id = t2.id;
                   QUERY PLAN                    
-------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = "*VALUES*".column1)
         ->  Seq Scan on t1
         ->  Hash
               ->  Values Scan on "*VALUES*"
 Optimizer: Postgres query optimizer
(7 rows)

/*+HashJoin(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, (VALUES(1,1),(2,2),(3,3)) AS t2(id,val) WHERE t1.id = t2.id;
LOG:  statement: /*+HashJoin(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, (VALUES(1,1),(2,2),(3,3)) AS t2(id,val) WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
not used hint:
HashJoin(t1 t2)
duplication hint:
error hint:
                   QUERY PLAN                    
-------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = "*VALUES*".column1)
         ->  Seq Scan on t1
         ->  Hash
               ->  Values Scan on "*VALUES*"
 Optimizer: Postgres query optimizer
(7 rows)

/*+HashJoin(t1 *VALUES*)*/
EXPLAIN (COSTS false) SELECT * FROM t1, (VALUES(1,1),(2,2),(3,3)) AS t2(id,val) WHERE t1.id = t2.id;
LOG:  statement: /*+HashJoin(t1 *VALUES*)*/
EXPLAIN (COSTS false) SELECT * FROM t1, (VALUES(1,1),(2,2),(3,3)) AS t2(id,val) WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
HashJoin(*VALUES* t1)
not used hint:
duplication hint:
error hint:
                   QUERY PLAN                    
-------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = "*VALUES*".column1)
         ->  Seq Scan on t1
         ->  Hash
               ->  Values Scan on "*VALUES*"
 Optimizer: Postgres query optimizer
(7 rows)

/*+HashJoin(t1 *VALUES*) IndexScan(t1) IndexScan(*VALUES*)*/
EXPLAIN (COSTS false) SELECT * FROM t1, (VALUES(1,1),(2,2),(3,3)) AS t2(id,val) WHERE t1.id = t2.id;
LOG:  statement: /*+HashJoin(t1 *VALUES*) IndexScan(t1) IndexScan(*VALUES*)*/
EXPLAIN (COSTS false) SELECT * FROM t1, (VALUES(1,1),(2,2),(3,3)) AS t2(id,val) WHERE t1.id = t2.id;
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
HashJoin(*VALUES* t1)
not used hint:
IndexScan(*VALUES*)
duplication hint:
error hint:
                   QUERY PLAN                    
-------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = "*VALUES*".column1)
         ->  Index Scan using t1_pkey on t1
         ->  Hash
               ->  Values Scan on "*VALUES*"
 Optimizer: Postgres query optimizer
(7 rows)

-- single table scan hint test
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  statement: EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 2 (returns $1)  (slice2)
     ->  Result
           InitPlan 1 (returns $0)  (slice3)
             ->  Limit
                   ->  Gather Motion 3:1  (slice4; segments: 3)
                         Merge Key: v_1.id
                         ->  Index Only Scan Backward using t1_pkey on t1 v_1
                               Index Cond: ((id IS NOT NULL) AND (id < 10))
   InitPlan 4 (returns $3)  (slice5)
     ->  Result
           InitPlan 3 (returns $2)  (slice6)
             ->  Limit
                   ->  Gather Motion 3:1  (slice7; segments: 3)
                         Merge Key: v_2.id
                         ->  Index Only Scan Backward using t1_pkey on t1 v_2
                               Index Cond: ((id IS NOT NULL) AND (id < 10))
   ->  Index Only Scan using t1_pkey on t1
         Index Cond: (id = $3)
 Optimizer: Postgres query optimizer
(20 rows)

/*+BitmapScan(v_1)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  statement: /*+BitmapScan(v_1)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  pg_hint_plan:
used hint:
BitmapScan(v_1)
not used hint:
duplication hint:
error hint:
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $1)  (slice2)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice3; segments: 3)
                 ->  Partial Aggregate
                       ->  Bitmap Heap Scan on t1 v_1
                             Recheck Cond: (id < 10)
                             ->  Bitmap Index Scan on t1_pkey
                                   Index Cond: (id < 10)
   InitPlan 3 (returns $3)  (slice4)
     ->  Result
           InitPlan 2 (returns $2)  (slice5)
             ->  Limit
                   ->  Gather Motion 3:1  (slice6; segments: 3)
                         Merge Key: v_2.id
                         ->  Index Only Scan Backward using t1_pkey on t1 v_2
                               Index Cond: ((id IS NOT NULL) AND (id < 10))
   ->  Index Only Scan using t1_pkey on t1
         Index Cond: (id = $3)
 Optimizer: Postgres query optimizer
(20 rows)

/*+BitmapScan(v_2)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  statement: /*+BitmapScan(v_2)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  pg_hint_plan:
used hint:
BitmapScan(v_2)
not used hint:
duplication hint:
error hint:
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 2 (returns $1)  (slice2)
     ->  Result
           InitPlan 1 (returns $0)  (slice3)
             ->  Limit
                   ->  Gather Motion 3:1  (slice4; segments: 3)
                         Merge Key: v_1.id
                         ->  Index Only Scan Backward using t1_pkey on t1 v_1
                               Index Cond: ((id IS NOT NULL) AND (id < 10))
   InitPlan 3 (returns $3)  (slice5)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice6; segments: 3)
                 ->  Partial Aggregate
                       ->  Bitmap Heap Scan on t1 v_2
                             Recheck Cond: (id < 10)
                             ->  Bitmap Index Scan on t1_pkey
                                   Index Cond: (id < 10)
   ->  Index Only Scan using t1_pkey on t1
         Index Cond: (id = $3)
 Optimizer: Postgres query optimizer
(20 rows)

/*+BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  statement: /*+BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
not used hint:
duplication hint:
error hint:
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 2 (returns $1)  (slice2)
     ->  Result
           InitPlan 1 (returns $0)  (slice3)
             ->  Limit
                   ->  Gather Motion 3:1  (slice4; segments: 3)
                         Merge Key: v_1.id
                         ->  Index Only Scan Backward using t1_pkey on t1 v_1
                               Index Cond: ((id IS NOT NULL) AND (id < 10))
   InitPlan 4 (returns $3)  (slice5)
     ->  Result
           InitPlan 3 (returns $2)  (slice6)
             ->  Limit
                   ->  Gather Motion 3:1  (slice7; segments: 3)
                         Merge Key: v_2.id
                         ->  Index Only Scan Backward using t1_pkey on t1 v_2
                               Index Cond: ((id IS NOT NULL) AND (id < 10))
   ->  Bitmap Heap Scan on t1
         Recheck Cond: (id = $3)
         ->  Bitmap Index Scan on t1_pkey
               Index Cond: (id = $3)
 Optimizer: Postgres query optimizer
(22 rows)

/*+BitmapScan(v_1)BitmapScan(v_2)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  statement: /*+BitmapScan(v_1)BitmapScan(v_2)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  pg_hint_plan:
used hint:
BitmapScan(v_1)
BitmapScan(v_2)
not used hint:
duplication hint:
error hint:
                          QUERY PLAN                          
--------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $1)  (slice2)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice3; segments: 3)
                 ->  Partial Aggregate
                       ->  Bitmap Heap Scan on t1 v_1
                             Recheck Cond: (id < 10)
                             ->  Bitmap Index Scan on t1_pkey
                                   Index Cond: (id < 10)
   InitPlan 2 (returns $3)  (slice4)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice5; segments: 3)
                 ->  Partial Aggregate
                       ->  Bitmap Heap Scan on t1 v_2
                             Recheck Cond: (id < 10)
                             ->  Bitmap Index Scan on t1_pkey
                                   Index Cond: (id < 10)
   ->  Index Only Scan using t1_pkey on t1
         Index Cond: (id = $3)
 Optimizer: Postgres query optimizer
(20 rows)

/*+BitmapScan(v_1)BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  statement: /*+BitmapScan(v_1)BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
BitmapScan(v_1)
not used hint:
duplication hint:
error hint:
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $1)  (slice2)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice3; segments: 3)
                 ->  Partial Aggregate
                       ->  Bitmap Heap Scan on t1 v_1
                             Recheck Cond: (id < 10)
                             ->  Bitmap Index Scan on t1_pkey
                                   Index Cond: (id < 10)
   InitPlan 3 (returns $3)  (slice4)
     ->  Result
           InitPlan 2 (returns $2)  (slice5)
             ->  Limit
                   ->  Gather Motion 3:1  (slice6; segments: 3)
                         Merge Key: v_2.id
                         ->  Index Only Scan Backward using t1_pkey on t1 v_2
                               Index Cond: ((id IS NOT NULL) AND (id < 10))
   ->  Bitmap Heap Scan on t1
         Recheck Cond: (id = $3)
         ->  Bitmap Index Scan on t1_pkey
               Index Cond: (id = $3)
 Optimizer: Postgres query optimizer
(22 rows)

/*+BitmapScan(v_2)BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  statement: /*+BitmapScan(v_2)BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
BitmapScan(v_2)
not used hint:
duplication hint:
error hint:
                                  QUERY PLAN                                  
------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 2 (returns $1)  (slice2)
     ->  Result
           InitPlan 1 (returns $0)  (slice3)
             ->  Limit
                   ->  Gather Motion 3:1  (slice4; segments: 3)
                         Merge Key: v_1.id
                         ->  Index Only Scan Backward using t1_pkey on t1 v_1
                               Index Cond: ((id IS NOT NULL) AND (id < 10))
   InitPlan 3 (returns $3)  (slice5)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice6; segments: 3)
                 ->  Partial Aggregate
                       ->  Bitmap Heap Scan on t1 v_2
                             Recheck Cond: (id < 10)
                             ->  Bitmap Index Scan on t1_pkey
                                   Index Cond: (id < 10)
   ->  Bitmap Heap Scan on t1
         Recheck Cond: (id = $3)
         ->  Bitmap Index Scan on t1_pkey
               Index Cond: (id = $3)
 Optimizer: Postgres query optimizer
(22 rows)

/*+BitmapScan(v_1)BitmapScan(v_2)BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  statement: /*+BitmapScan(v_1)BitmapScan(v_2)BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT (SELECT max(id) FROM t1 v_1 WHERE id < 10), id FROM v1 WHERE v1.id = (SELECT max(id) FROM t1 v_2 WHERE id < 10);
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
BitmapScan(v_1)
BitmapScan(v_2)
not used hint:
duplication hint:
error hint:
                          QUERY PLAN                          
--------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $1)  (slice2)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice3; segments: 3)
                 ->  Partial Aggregate
                       ->  Bitmap Heap Scan on t1 v_1
                             Recheck Cond: (id < 10)
                             ->  Bitmap Index Scan on t1_pkey
                                   Index Cond: (id < 10)
   InitPlan 2 (returns $3)  (slice4)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice5; segments: 3)
                 ->  Partial Aggregate
                       ->  Bitmap Heap Scan on t1 v_2
                             Recheck Cond: (id < 10)
                             ->  Bitmap Index Scan on t1_pkey
                                   Index Cond: (id < 10)
   ->  Bitmap Heap Scan on t1
         Recheck Cond: (id = $3)
         ->  Bitmap Index Scan on t1_pkey
               Index Cond: (id = $3)
 Optimizer: Postgres query optimizer
(22 rows)

-- full scan hint pattern test
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Tid Scan on t1
         TID Cond: (ctid = '(1,1)'::tid)
         Filter: (id < 10)
 Optimizer: Postgres query optimizer
(5 rows)

/*+SeqScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
LOG:  statement: /*+SeqScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                       
-------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on t1
         Filter: ((id < 10) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(4 rows)

/*+IndexScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
LOG:  statement: /*+IndexScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Index Scan using t1_pkey on t1
         Index Cond: (id < 10)
         Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(5 rows)

/*+BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Bitmap Heap Scan on t1
         Recheck Cond: (id < 10)
         Filter: (ctid = '(1,1)'::tid)
         ->  Bitmap Index Scan on t1_pkey
               Index Cond: (id < 10)
 Optimizer: Postgres query optimizer
(7 rows)

/*+TidScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
LOG:  statement: /*+TidScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(t1)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Tid Scan on t1
         TID Cond: (ctid = '(1,1)'::tid)
         Filter: (id < 10)
 Optimizer: Postgres query optimizer
(5 rows)

/*+NoSeqScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
LOG:  statement: /*+NoSeqScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoSeqScan(t1)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Tid Scan on t1
         TID Cond: (ctid = '(1,1)'::tid)
         Filter: (id < 10)
 Optimizer: Postgres query optimizer
(5 rows)

/*+NoIndexScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
LOG:  statement: /*+NoIndexScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoIndexScan(t1)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Tid Scan on t1
         TID Cond: (ctid = '(1,1)'::tid)
         Filter: (id < 10)
 Optimizer: Postgres query optimizer
(5 rows)

/*+NoBitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
LOG:  statement: /*+NoBitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoBitmapScan(t1)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Tid Scan on t1
         TID Cond: (ctid = '(1,1)'::tid)
         Filter: (id < 10)
 Optimizer: Postgres query optimizer
(5 rows)

/*+NoTidScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
LOG:  statement: /*+NoTidScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE id < 10 AND ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoTidScan(t1)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Index Scan using t1_pkey on t1
         Index Cond: (id < 10)
         Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(5 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+SeqScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+SeqScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
SeqScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Seq Scan on t2
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+SeqScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
IndexScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Index Scan using t2_pkey on t2
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+SeqScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Bitmap Heap Scan on t2
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on t2_pkey
 Optimizer: Postgres query optimizer
(10 rows)

/*+SeqScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
TidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+SeqScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
NoSeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+SeqScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
NoIndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+SeqScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
NoBitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+SeqScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
NoTidScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Seq Scan on t2
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+IndexScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Index Scan using t2_pkey on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+IndexScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
SeqScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Seq Scan on t2
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+IndexScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
IndexScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Index Scan using t2_pkey on t2
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+IndexScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Bitmap Heap Scan on t2
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on t2_pkey
 Optimizer: Postgres query optimizer
(10 rows)

/*+IndexScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
TidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+IndexScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
NoSeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+IndexScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
NoIndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+IndexScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
NoBitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+IndexScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(t1)
NoTidScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Seq Scan on t2
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Bitmap Heap Scan on t2
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t2_pkey
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Bitmap Heap Scan on t2
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t2_pkey
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+BitmapScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
SeqScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Seq Scan on t2
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+BitmapScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
IndexScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Index Scan using t2_pkey on t2
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+BitmapScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Bitmap Heap Scan on t2
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on t2_pkey
 Optimizer: Postgres query optimizer
(11 rows)

/*+BitmapScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
TidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+BitmapScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
NoSeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+BitmapScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
NoIndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+BitmapScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
NoBitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+BitmapScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
NoTidScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t1_pkey
         ->  Hash
               ->  Seq Scan on t2
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+TidScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+TidScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(t1)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Tid Scan on t2
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+TidScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+TidScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(t1)
SeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+TidScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+TidScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(t1)
IndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Index Scan using t2_pkey on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+TidScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+TidScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(t1)
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Bitmap Heap Scan on t2
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t2_pkey
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+TidScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+TidScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(t1)
TidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+TidScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+TidScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(t1)
NoSeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Tid Scan on t2
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+TidScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+TidScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(t1)
NoIndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Tid Scan on t2
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+TidScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+TidScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(t1)
NoBitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Tid Scan on t2
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+TidScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+TidScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(t1)
NoTidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoSeqScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoSeqScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoSeqScan(t1)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoSeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoSeqScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoSeqScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoSeqScan(t1)
SeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoSeqScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoSeqScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoSeqScan(t1)
IndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Index Scan using t2_pkey on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoSeqScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoSeqScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoSeqScan(t1)
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Bitmap Heap Scan on t2
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t2_pkey
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+NoSeqScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoSeqScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoSeqScan(t1)
TidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoSeqScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoSeqScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoSeqScan(t1)
NoSeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoSeqScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoSeqScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoSeqScan(t1)
NoIndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoSeqScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoSeqScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoSeqScan(t1)
NoBitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoSeqScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoSeqScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoSeqScan(t1)
NoTidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoIndexScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoIndexScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoIndexScan(t1)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoIndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoIndexScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoIndexScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoIndexScan(t1)
SeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoIndexScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoIndexScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoIndexScan(t1)
IndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Index Scan using t2_pkey on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoIndexScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoIndexScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoIndexScan(t1)
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Bitmap Heap Scan on t2
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t2_pkey
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+NoIndexScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoIndexScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoIndexScan(t1)
TidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoIndexScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoIndexScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoIndexScan(t1)
NoSeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoIndexScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoIndexScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoIndexScan(t1)
NoIndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoIndexScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoIndexScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoIndexScan(t1)
NoBitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoIndexScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoIndexScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoIndexScan(t1)
NoTidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoBitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoBitmapScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoBitmapScan(t1)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoBitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoBitmapScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoBitmapScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoBitmapScan(t1)
SeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoBitmapScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoBitmapScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoBitmapScan(t1)
IndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Index Scan using t2_pkey on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoBitmapScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoBitmapScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoBitmapScan(t1)
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Bitmap Heap Scan on t2
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t2_pkey
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(10 rows)

/*+NoBitmapScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoBitmapScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoBitmapScan(t1)
TidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoBitmapScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoBitmapScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoBitmapScan(t1)
NoSeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoBitmapScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoBitmapScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoBitmapScan(t1)
NoIndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoBitmapScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoBitmapScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoBitmapScan(t1)
NoBitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoBitmapScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoBitmapScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoBitmapScan(t1)
NoTidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoTidScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoTidScan(t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoTidScan(t1)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoTidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoTidScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoTidScan(t1) SeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoTidScan(t1)
SeqScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Seq Scan on t2
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoTidScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoTidScan(t1) IndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoTidScan(t1)
IndexScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Index Scan using t2_pkey on t2
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoTidScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoTidScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoTidScan(t1)
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Bitmap Heap Scan on t2
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on t2_pkey
 Optimizer: Postgres query optimizer
(10 rows)

/*+NoTidScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoTidScan(t1) TidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoTidScan(t1)
TidScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoTidScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoTidScan(t1) NoSeqScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoTidScan(t1)
NoSeqScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoTidScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoTidScan(t1) NoIndexScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoTidScan(t1)
NoIndexScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoTidScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoTidScan(t1) NoBitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoTidScan(t1)
NoBitmapScan(t2)
not used hint:
duplication hint:
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

/*+NoTidScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+NoTidScan(t1) NoTidScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NoTidScan(t1)
NoTidScan(t2)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Seq Scan on t2
                     Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(9 rows)

-- additional test
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)' AND t1.id < 10 AND t2.id < 10;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)' AND t1.id < 10 AND t2.id < 10;
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Tid Scan on t1
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: (id < 10)
         ->  Hash
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
                     Filter: (id < 10)
 Optimizer: Postgres query optimizer
(11 rows)

/*+BitmapScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)' AND t1.id < 10 AND t2.id < 10;
LOG:  statement: /*+BitmapScan(t1) BitmapScan(t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)' AND t1.id < 10 AND t2.id < 10;
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(t1)
BitmapScan(t2)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Bitmap Heap Scan on t1
               Recheck Cond: (id < 10)
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on t1_pkey
                     Index Cond: (id < 10)
         ->  Hash
               ->  Bitmap Heap Scan on t2
                     Recheck Cond: (id < 10)
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on t2_pkey
                           Index Cond: (id < 10)
 Optimizer: Postgres query optimizer
(15 rows)

-- outer join test
EXPLAIN (COSTS false) SELECT * FROM t1 FULL OUTER JOIN  t2 ON (t1.id = t2.id);
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1 FULL OUTER JOIN  t2 ON (t1.id = t2.id);
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Full Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

/*+MergeJoin(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1 FULL OUTER JOIN  t2 ON (t1.id = t2.id);
LOG:  statement: /*+MergeJoin(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1 FULL OUTER JOIN  t2 ON (t1.id = t2.id);
LOG:  pg_hint_plan:
used hint:
MergeJoin(t1 t2)
not used hint:
duplication hint:
error hint:
                 QUERY PLAN                 
--------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Full Join
         Merge Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
         ->  Sort
               Sort Key: t2.id
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(8 rows)

-- Cannot work
/*+NestLoop(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1 FULL OUTER JOIN  t2 ON (t1.id = t2.id);
LOG:  statement: /*+NestLoop(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1 FULL OUTER JOIN  t2 ON (t1.id = t2.id);
LOG:  pg_hint_plan:
used hint:
NestLoop(t1 t2)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Full Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

-- inheritance tables test
SET constraint_exclusion TO off;
LOG:  statement: SET constraint_exclusion TO off;
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p1 p1_1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c1 p1_2
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c2 p1_3
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c3 p1_4
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c4 p1_5
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c1_c1 p1_6
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c1_c2 p1_7
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c3_c1 p1_8
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c3_c2 p1_9
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(21 rows)

SET constraint_exclusion TO on;
LOG:  statement: SET constraint_exclusion TO on;
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p1 p1_1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c1 p1_2
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c1_c1 p1_3
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c1_c2 p1_4
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(11 rows)

SET constraint_exclusion TO off;
LOG:  statement: SET constraint_exclusion TO off;
/*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(p1)
not used hint:
duplication hint:
error hint:
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p1 p1_1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c1 p1_2
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c2 p1_3
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c3 p1_4
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c4 p1_5
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c1_c1 p1_6
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c1_c2 p1_7
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c3_c1 p1_8
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c3_c2 p1_9
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(21 rows)

/*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(p1)
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                          
-------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Index Scan using p1_pkey on p1 p1_1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p1_c1_pkey on p1_c1 p1_2
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p1_c2_pkey on p1_c2 p1_3
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p1_c3_pkey on p1_c3 p1_4
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p1_c4_pkey on p1_c4 p1_5
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p1_c1_c1_pkey on p1_c1_c1 p1_6
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p1_c1_c2_pkey on p1_c1_c2 p1_7
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p1_c3_c1_pkey on p1_c3_c1 p1_8
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p1_c3_c2_pkey on p1_c3_c2 p1_9
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(30 rows)

/*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(p1)
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                          
-------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Bitmap Heap Scan on p1 p1_1
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
         ->  Bitmap Heap Scan on p1_c1 p1_2
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_c1_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
         ->  Bitmap Heap Scan on p1_c2 p1_3
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_c2_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
         ->  Bitmap Heap Scan on p1_c3 p1_4
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_c3_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
         ->  Bitmap Heap Scan on p1_c4 p1_5
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_c4_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
         ->  Bitmap Heap Scan on p1_c1_c1 p1_6
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_c1_c1_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
         ->  Bitmap Heap Scan on p1_c1_c2 p1_7
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_c1_c2_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
         ->  Bitmap Heap Scan on p1_c3_c1 p1_8
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_c3_c1_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
         ->  Bitmap Heap Scan on p1_c3_c2 p1_9
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_c3_c2_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(48 rows)

/*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(p1)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Tid Scan on p1 p1_1
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
         ->  Tid Scan on p1_c1 p1_2
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
         ->  Tid Scan on p1_c2 p1_3
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
         ->  Tid Scan on p1_c3 p1_4
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
         ->  Tid Scan on p1_c4 p1_5
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
         ->  Tid Scan on p1_c1_c1 p1_6
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
         ->  Tid Scan on p1_c1_c2 p1_7
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
         ->  Tid Scan on p1_c3_c1 p1_8
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
         ->  Tid Scan on p1_c3_c2 p1_9
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(30 rows)

SET constraint_exclusion TO on;
LOG:  statement: SET constraint_exclusion TO on;
/*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(p1)
not used hint:
duplication hint:
error hint:
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p1 p1_1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c1 p1_2
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c1_c1 p1_3
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p1_c1_c2 p1_4
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(11 rows)

/*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(p1)
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                          
-------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Index Scan using p1_pkey on p1 p1_1
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p1_c1_pkey on p1_c1 p1_2
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p1_c1_c1_pkey on p1_c1_c1 p1_3
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Index Scan using p1_c1_c2_pkey on p1_c1_c2 p1_4
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(15 rows)

/*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(p1)
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                          
-------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Bitmap Heap Scan on p1 p1_1
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
         ->  Bitmap Heap Scan on p1_c1 p1_2
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_c1_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
         ->  Bitmap Heap Scan on p1_c1_c1 p1_3
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_c1_c1_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
         ->  Bitmap Heap Scan on p1_c1_c2 p1_4
               Recheck Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
               ->  Bitmap Index Scan on p1_c1_c2_pkey
                     Index Cond: ((id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(23 rows)

/*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(p1)
not used hint:
duplication hint:
error hint:
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Tid Scan on p1 p1_1
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
         ->  Tid Scan on p1_c1 p1_2
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
         ->  Tid Scan on p1_c1_c1 p1_3
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
         ->  Tid Scan on p1_c1_c2 p1_4
               TID Cond: (ctid = '(1,1)'::tid)
               Filter: ((id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(15 rows)

SET constraint_exclusion TO off;
LOG:  statement: SET constraint_exclusion TO off;
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (p1.id = t1.id)
         ->  Append
               ->  Seq Scan on p1 p1_1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c1 p1_2
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c2 p1_3
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c3 p1_4
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c4 p1_5
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c1_c1 p1_6
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c1_c2 p1_7
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c3_c1 p1_8
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c3_c2 p1_9
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
         ->  Hash
               ->  Index Scan using t1_pkey on t1
                     Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(26 rows)

SET constraint_exclusion TO on;
LOG:  statement: SET constraint_exclusion TO on;
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

SET constraint_exclusion TO off;
LOG:  statement: SET constraint_exclusion TO off;
/*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(p1)
not used hint:
duplication hint:
error hint:
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (p1.id = t1.id)
         ->  Append
               ->  Seq Scan on p1 p1_1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c1 p1_2
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c2 p1_3
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c3 p1_4
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c4 p1_5
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c1_c1 p1_6
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c1_c2 p1_7
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c3_c1 p1_8
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c3_c2 p1_9
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
         ->  Hash
               ->  Index Scan using t1_pkey on t1
                     Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(26 rows)

/*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(p1)
not used hint:
duplication hint:
error hint:
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (p1.id = t1.id)
         ->  Append
               ->  Index Scan using p1_pkey on p1 p1_1
                     Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
               ->  Index Scan using p1_c1_pkey on p1_c1 p1_2
                     Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
               ->  Index Scan using p1_c2_pkey on p1_c2 p1_3
                     Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
               ->  Index Scan using p1_c3_pkey on p1_c3 p1_4
                     Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
               ->  Index Scan using p1_c4_pkey on p1_c4 p1_5
                     Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
               ->  Index Scan using p1_c1_c1_pkey on p1_c1_c1 p1_6
                     Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
               ->  Index Scan using p1_c1_c2_pkey on p1_c1_c2 p1_7
                     Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
               ->  Index Scan using p1_c3_c1_pkey on p1_c3_c1 p1_8
                     Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
               ->  Index Scan using p1_c3_c2_pkey on p1_c3_c2 p1_9
                     Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Index Scan using t1_pkey on t1
                     Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(35 rows)

/*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(p1)
not used hint:
duplication hint:
error hint:
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (p1.id = t1.id)
         ->  Append
               ->  Bitmap Heap Scan on p1 p1_1
                     Recheck Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on p1_pkey
                           Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Bitmap Heap Scan on p1_c1 p1_2
                     Recheck Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on p1_c1_pkey
                           Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Bitmap Heap Scan on p1_c2 p1_3
                     Recheck Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on p1_c2_pkey
                           Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Bitmap Heap Scan on p1_c3 p1_4
                     Recheck Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on p1_c3_pkey
                           Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Bitmap Heap Scan on p1_c4 p1_5
                     Recheck Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on p1_c4_pkey
                           Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Bitmap Heap Scan on p1_c1_c1 p1_6
                     Recheck Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on p1_c1_c1_pkey
                           Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Bitmap Heap Scan on p1_c1_c2 p1_7
                     Recheck Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on p1_c1_c2_pkey
                           Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Bitmap Heap Scan on p1_c3_c1 p1_8
                     Recheck Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on p1_c3_c1_pkey
                           Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Bitmap Heap Scan on p1_c3_c2 p1_9
                     Recheck Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on p1_c3_c2_pkey
                           Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
         ->  Hash
               ->  Index Scan using t1_pkey on t1
                     Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(53 rows)

/*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(p1)
not used hint:
duplication hint:
error hint:
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (p1.id = t1.id)
         ->  Append
               ->  Tid Scan on p1 p1_1
                     TID Cond: (ctid = '(1,1)'::tid)
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Tid Scan on p1_c1 p1_2
                     TID Cond: (ctid = '(1,1)'::tid)
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Tid Scan on p1_c2 p1_3
                     TID Cond: (ctid = '(1,1)'::tid)
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Tid Scan on p1_c3 p1_4
                     TID Cond: (ctid = '(1,1)'::tid)
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Tid Scan on p1_c4 p1_5
                     TID Cond: (ctid = '(1,1)'::tid)
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Tid Scan on p1_c1_c1 p1_6
                     TID Cond: (ctid = '(1,1)'::tid)
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Tid Scan on p1_c1_c2 p1_7
                     TID Cond: (ctid = '(1,1)'::tid)
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Tid Scan on p1_c3_c1 p1_8
                     TID Cond: (ctid = '(1,1)'::tid)
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10))
               ->  Tid Scan on p1_c3_c2 p1_9
                     TID Cond: (ctid = '(1,1)'::tid)
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10))
         ->  Hash
               ->  Index Scan using t1_pkey on t1
                     Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(35 rows)

/*+NestLoop(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+NestLoop(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NestLoop(p1 t1)
not used hint:
duplication hint:
error hint:
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         Join Filter: (p1.id = t1.id)
         ->  Index Scan using t1_pkey on t1
               Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
         ->  Append
               ->  Seq Scan on p1 p1_1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c1 p1_2
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c2 p1_3
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c3 p1_4
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c4 p1_5
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c1_c1 p1_6
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c1_c2 p1_7
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c3_c1 p1_8
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c3_c2 p1_9
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(25 rows)

/*+MergeJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+MergeJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
MergeJoin(p1 t1)
not used hint:
duplication hint:
error hint:
                                              QUERY PLAN                                               
-------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Join
         Merge Cond: (p1.id = t1.id)
         ->  Sort
               Sort Key: p1.id
               ->  Append
                     ->  Seq Scan on p1 p1_1
                           Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
                     ->  Seq Scan on p1_c1 p1_2
                           Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
                     ->  Seq Scan on p1_c2 p1_3
                           Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
                     ->  Seq Scan on p1_c3 p1_4
                           Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
                     ->  Seq Scan on p1_c4 p1_5
                           Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
                     ->  Seq Scan on p1_c1_c1 p1_6
                           Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
                     ->  Seq Scan on p1_c1_c2 p1_7
                           Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
                     ->  Seq Scan on p1_c3_c1 p1_8
                           Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
                     ->  Seq Scan on p1_c3_c2 p1_9
                           Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
         ->  Index Scan using t1_pkey on t1
               Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(27 rows)

/*+HashJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+HashJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
HashJoin(p1 t1)
not used hint:
duplication hint:
error hint:
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (p1.id = t1.id)
         ->  Append
               ->  Seq Scan on p1 p1_1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c1 p1_2
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c2 p1_3
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c3 p1_4
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c4 p1_5
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c1_c1 p1_6
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c1_c2 p1_7
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c3_c1 p1_8
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
               ->  Seq Scan on p1_c3_c2 p1_9
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
         ->  Hash
               ->  Index Scan using t1_pkey on t1
                     Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(26 rows)

SET constraint_exclusion TO on;
LOG:  statement: SET constraint_exclusion TO on;
/*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
not used hint:
SeqScan(p1)
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

/*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
not used hint:
IndexScan(p1)
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

/*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
not used hint:
BitmapScan(p1)
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

/*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
not used hint:
TidScan(p1)
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

/*+NestLoop(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+NestLoop(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NestLoop(p1 t1)
not used hint:
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

/*+MergeJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+MergeJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
MergeJoin(p1 t1)
not used hint:
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

/*+HashJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+HashJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
HashJoin(p1 t1)
not used hint:
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

SET constraint_exclusion TO off;
LOG:  statement: SET constraint_exclusion TO off;
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on p1
         Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(4 rows)

SET constraint_exclusion TO on;
LOG:  statement: SET constraint_exclusion TO on;
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on p1
         Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(4 rows)

SET constraint_exclusion TO off;
LOG:  statement: SET constraint_exclusion TO off;
/*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(p1)
not used hint:
duplication hint:
error hint:
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on p1
         Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(4 rows)

/*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(p1)
not used hint:
duplication hint:
error hint:
                   QUERY PLAN                    
-------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Index Scan using p1_pkey on p1
         Index Cond: ((id >= 50) AND (id <= 51))
         Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(5 rows)

/*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(p1)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                       
-------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Bitmap Heap Scan on p1
         Recheck Cond: ((id >= 50) AND (id <= 51))
         Filter: (ctid = '(1,1)'::tid)
         ->  Bitmap Index Scan on p1_pkey
               Index Cond: ((id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(7 rows)

/*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(p1)
not used hint:
duplication hint:
error hint:
                 QUERY PLAN                  
---------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Tid Scan on p1
         TID Cond: (ctid = '(1,1)'::tid)
         Filter: ((id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(5 rows)

/*+NestLoop(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+NestLoop(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NestLoop(p1 t1)
not used hint:
duplication hint:
error hint:
                                        QUERY PLAN                                         
-------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         Join Filter: (p1.id = t1.id)
         ->  Seq Scan on p1
               Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
         ->  Index Scan using t1_pkey on t1
               Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(8 rows)

/*+MergeJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+MergeJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
MergeJoin(p1 t1)
not used hint:
duplication hint:
error hint:
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Join
         Merge Cond: (p1.id = t1.id)
         ->  Sort
               Sort Key: p1.id
               ->  Seq Scan on p1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
         ->  Index Scan using t1_pkey on t1
               Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(10 rows)

/*+HashJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+HashJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
HashJoin(p1 t1)
not used hint:
duplication hint:
error hint:
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = p1.id)
         ->  Index Scan using t1_pkey on t1
               Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
         ->  Hash
               ->  Seq Scan on p1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(9 rows)

SET constraint_exclusion TO on;
LOG:  statement: SET constraint_exclusion TO on;
/*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(p1)
not used hint:
duplication hint:
error hint:
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Seq Scan on p1
         Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(4 rows)

/*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(p1)
not used hint:
duplication hint:
error hint:
                   QUERY PLAN                    
-------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Index Scan using p1_pkey on p1
         Index Cond: ((id >= 50) AND (id <= 51))
         Filter: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(5 rows)

/*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(p1)
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                       
-------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Bitmap Heap Scan on p1
         Recheck Cond: ((id >= 50) AND (id <= 51))
         Filter: (ctid = '(1,1)'::tid)
         ->  Bitmap Index Scan on p1_pkey
               Index Cond: ((id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(7 rows)

/*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
LOG:  statement: /*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1 WHERE id >= 50 AND id <= 51 AND p1.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(p1)
not used hint:
duplication hint:
error hint:
                 QUERY PLAN                  
---------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Tid Scan on p1
         TID Cond: (ctid = '(1,1)'::tid)
         Filter: ((id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(5 rows)

/*+NestLoop(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+NestLoop(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
NestLoop(p1 t1)
not used hint:
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

/*+MergeJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+MergeJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
MergeJoin(p1 t1)
not used hint:
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

/*+HashJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+HashJoin(p1 t1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
HashJoin(p1 t1)
not used hint:
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

SET constraint_exclusion TO off;
LOG:  statement: SET constraint_exclusion TO off;
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = p1.id)
         ->  Index Scan using t1_pkey on t1
               Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
         ->  Hash
               ->  Seq Scan on p1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(9 rows)

SET constraint_exclusion TO on;
LOG:  statement: SET constraint_exclusion TO on;
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

SET constraint_exclusion TO off;
LOG:  statement: SET constraint_exclusion TO off;
/*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
SeqScan(p1)
not used hint:
duplication hint:
error hint:
                                           QUERY PLAN                                            
-------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = p1.id)
         ->  Index Scan using t1_pkey on t1
               Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
         ->  Hash
               ->  Seq Scan on p1
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(9 rows)

/*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
IndexScan(p1)
not used hint:
duplication hint:
error hint:
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (p1.id = t1.id)
         ->  Index Scan using p1_pkey on p1
               Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
               Filter: (ctid = '(1,1)'::tid)
         ->  Hash
               ->  Index Scan using t1_pkey on t1
                     Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
 Optimizer: Postgres query optimizer
(10 rows)

/*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
BitmapScan(p1)
not used hint:
duplication hint:
error hint:
                                   QUERY PLAN                                    
---------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = p1.id)
         ->  Index Scan using t1_pkey on t1
               Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
         ->  Hash
               ->  Bitmap Heap Scan on p1
                     Recheck Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
                     Filter: (ctid = '(1,1)'::tid)
                     ->  Bitmap Index Scan on p1_pkey
                           Index Cond: ((id >= 50) AND (id <= 51) AND (id < 10))
 Optimizer: Postgres query optimizer
(12 rows)

/*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
TidScan(p1)
not used hint:
duplication hint:
error hint:
                              QUERY PLAN                               
-----------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = p1.id)
         ->  Index Scan using t1_pkey on t1
               Index Cond: ((id < 10) AND (id >= 50) AND (id <= 51))
         ->  Hash
               ->  Tid Scan on p1
                     TID Cond: (ctid = '(1,1)'::tid)
                     Filter: ((id >= 50) AND (id <= 51) AND (id < 10))
 Optimizer: Postgres query optimizer
(10 rows)

SET constraint_exclusion TO on;
LOG:  statement: SET constraint_exclusion TO on;
/*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+SeqScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
not used hint:
SeqScan(p1)
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

/*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+IndexScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
not used hint:
IndexScan(p1)
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

/*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+BitmapScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
not used hint:
BitmapScan(p1)
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

/*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
LOG:  statement: /*+TidScan(p1)*/
EXPLAIN (COSTS false) SELECT * FROM ONLY p1, t1 WHERE p1.id >= 50 AND p1.id <= 51 AND p1.ctid = '(1,1)' AND p1.id = t1.id AND t1.id < 10;
NOTICE:  SELECT uses system-defined column "p1.ctid" without the necessary companion column "p1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  pg_hint_plan:
used hint:
not used hint:
TidScan(p1)
duplication hint:
error hint:
             QUERY PLAN              
-------------------------------------
 Result
   One-Time Filter: false
 Optimizer: Postgres query optimizer
(3 rows)

-- IndexScan is safe for unordered indexes
CREATE TABLE ischk (a text, b tsvector) PARTITION BY LIST(a);
CREATE TABLE ischk_d1 PARTITION OF ischk FOR VALUES IN (0);
CREATE TABLE ischk_d2 PARTITION OF ischk FOR VALUES IN (1);
CREATE INDEX ischk_idx ON ischk USING gin (b);
/*+ IndexScan(ischk ischk_idx) */
EXPLAIN (COSTS false) SELECT * FROM ischk WHERE b = 'x';
LOG:  statement: /*+ IndexScan(ischk ischk_idx) */
EXPLAIN (COSTS false) SELECT * FROM ischk WHERE b = 'x';
LOG:  available indexes for IndexScan(ischk_d1): ischk_d1_b_idx
LOG:  available indexes for IndexScan(ischk_d2): ischk_d2_b_idx
LOG:  pg_hint_plan:
used hint:
IndexScan(ischk ischk_idx)
not used hint:
duplication hint:
error hint:
                  QUERY PLAN                   
-----------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on ischk_d1 ischk_1
               Filter: (b = '''x'''::tsvector)
         ->  Seq Scan on ischk_d2 ischk_2
               Filter: (b = '''x'''::tsvector)
 Optimizer: Postgres query optimizer
(7 rows)

DROP TABLE ischk;
-- quote test
/*+SeqScan("""t1 )	")IndexScan("t	2 """)HashJoin("""t1 )	"T3"t	2 """)Leading("""t1 )	"T3"t	2 """)Set(application_name"a	a	a""	a	A")*/
EXPLAIN (COSTS false) SELECT * FROM t1 """t1 )	", t2 "t	2 """, t3 "T3" WHERE """t1 )	".id = "t	2 """.id AND """t1 )	".id = "T3".id;
LOG:  statement: /*+SeqScan("""t1 )	")IndexScan("t	2 """)HashJoin("""t1 )	"T3"t	2 """)Leading("""t1 )	"T3"t	2 """)Set(application_name"a	a	a""	a	A")*/
EXPLAIN (COSTS false) SELECT * FROM t1 """t1 )	", t2 "t	2 """, t3 "T3" WHERE """t1 )	".id = "t	2 """.id AND """t1 )	".id = "T3".id;
LOG:  pg_hint_plan:
used hint:
SeqScan("""t1 )	")
IndexScan("t	2 """)
HashJoin("""t1 )	" T3 "t	2 """)
Leading("""t1 )	" T3 "t	2 """)
Set(application_name "a	a	a""	a	A")
not used hint:
duplication hint:
error hint:
                       QUERY PLAN                        
---------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: ("t  2 """.id = """t1 )      ".id)
         ->  Index Scan using t2_pkey on t2 "t   2 """
         ->  Hash
               ->  Hash Join
                     Hash Cond: ("""t1 ) ".id = "T3".id)
                     ->  Seq Scan on t1 """t1 )  "
                     ->  Hash
                           ->  Seq Scan on t3 "T3"
 Optimizer: Postgres query optimizer
(11 rows)

-- duplicate hint test
/*+SeqScan(t1)SeqScan(t2)IndexScan(t1)IndexScan(t2)BitmapScan(t1)BitmapScan(t2)TidScan(t1)TidScan(t2)HashJoin(t1 t2)NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
LOG:  statement: /*+SeqScan(t1)SeqScan(t2)IndexScan(t1)IndexScan(t2)BitmapScan(t1)BitmapScan(t2)TidScan(t1)TidScan(t2)HashJoin(t1 t2)NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.ctid = '(1,1)' AND t2.ctid = '(1,1)';
INFO:  pg_hint_plan: hint syntax error at or near "SeqScan(t1)SeqScan(t2)IndexScan(t1)IndexScan(t2)BitmapScan(t1)BitmapScan(t2)TidScan(t1)TidScan(t2)HashJoin(t1 t2)NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict scan method hint.
INFO:  pg_hint_plan: hint syntax error at or near "IndexScan(t1)IndexScan(t2)BitmapScan(t1)BitmapScan(t2)TidScan(t1)TidScan(t2)HashJoin(t1 t2)NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict scan method hint.
INFO:  pg_hint_plan: hint syntax error at or near "BitmapScan(t1)BitmapScan(t2)TidScan(t1)TidScan(t2)HashJoin(t1 t2)NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict scan method hint.
INFO:  pg_hint_plan: hint syntax error at or near "SeqScan(t2)IndexScan(t1)IndexScan(t2)BitmapScan(t1)BitmapScan(t2)TidScan(t1)TidScan(t2)HashJoin(t1 t2)NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict scan method hint.
INFO:  pg_hint_plan: hint syntax error at or near "IndexScan(t2)BitmapScan(t1)BitmapScan(t2)TidScan(t1)TidScan(t2)HashJoin(t1 t2)NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict scan method hint.
INFO:  pg_hint_plan: hint syntax error at or near "BitmapScan(t2)TidScan(t1)TidScan(t2)HashJoin(t1 t2)NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict scan method hint.
INFO:  pg_hint_plan: hint syntax error at or near "HashJoin(t1 t2)NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict join method hint.
INFO:  pg_hint_plan: hint syntax error at or near "NestLoop(t2 t1)MergeJoin(t1 t2)Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict join method hint.
INFO:  pg_hint_plan: hint syntax error at or near "Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict set hint.
NOTICE:  SELECT uses system-defined column "t1.ctid" without the necessary companion column "t1.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
NOTICE:  SELECT uses system-defined column "t2.ctid" without the necessary companion column "t2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
INFO:  pg_hint_plan: hint syntax error at or near "Leading(t1 t2)Leading(t2 t1)Set(enable_seqscan off)Set(enable_mergejoin on)Set(enable_seqscan on)"
DETAIL:  Conflict leading hint.
LOG:  pg_hint_plan:
used hint:
TidScan(t1)
TidScan(t2)
MergeJoin(t1 t2)
Leading(t2 t1)
Set(enable_mergejoin on)
Set(enable_seqscan on)
not used hint:
duplication hint:
SeqScan(t1)
IndexScan(t1)
BitmapScan(t1)
SeqScan(t2)
IndexScan(t2)
BitmapScan(t2)
HashJoin(t1 t2)
NestLoop(t1 t2)
Leading(t1 t2)
Set(enable_seqscan off)
error hint:
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Join
         Merge Cond: (t1.id = t2.id)
         ->  Sort
               Sort Key: t1.id
               ->  Tid Scan on t1
                     TID Cond: (ctid = '(1,1)'::tid)
         ->  Sort
               Sort Key: t2.id
               ->  Tid Scan on t2
                     TID Cond: (ctid = '(1,1)'::tid)
 Optimizer: Postgres query optimizer
(12 rows)

-- sub query Leading hint test
SET from_collapse_limit TO 100;
LOG:  statement: SET from_collapse_limit TO 100;
SET geqo_threshold TO 100;
LOG:  statement: SET geqo_threshold TO 100;
WARNING:  "geqo_threshold": setting is ignored because it is defunct
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
LOG:  statement: EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $0)  (slice4)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice5; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1_2.id = t2_2.id)
                             ->  Seq Scan on t1 t1_2
                             ->  Hash
                                   ->  Hash Join
                                         Hash Cond: (t2_2.id = t3_2.id)
                                         ->  Seq Scan on t2 t2_2
                                         ->  Hash
                                               ->  Seq Scan on t3 t3_2
   InitPlan 2 (returns $1)  (slice6)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice7; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1_4.id = t2_4.id)
                             ->  Seq Scan on t1 t1_4
                             ->  Hash
                                   ->  Hash Join
                                         Hash Cond: (t2_4.id = t3_4.id)
                                         ->  Seq Scan on t2 t2_4
                                         ->  Hash
                                               ->  Seq Scan on t3 t3_4
   ->  Nested Loop
         ->  Redistribute Motion 1:3  (slice2; segments: 1)
               Hash Key: (max(t1_5.id))
               ->  Finalize Aggregate
                     Filter: (max(t1_5.id) = $1)
                     ->  Gather Motion 3:1  (slice3; segments: 3)
                           ->  Partial Aggregate
                                 ->  Hash Join
                                       Hash Cond: (t1_5.id = t2_5.id)
                                       ->  Seq Scan on t1 t1_5
                                       ->  Hash
                                             ->  Hash Join
                                                   Hash Cond: (t2_5.id = t3_5.id)
                                                   ->  Seq Scan on t2 t2_5
                                                   ->  Hash
                                                         ->  Seq Scan on t3 t3_5
         ->  Nested Loop
               ->  Nested Loop
                     ->  Nested Loop
                           ->  Index Only Scan using t1_pkey on t1 t1_1
                                 Index Cond: (id = $1)
                           ->  Seq Scan on t2 t2_1
                                 Filter: (id = $1)
                     ->  Seq Scan on t3 t3_1
                           Filter: (id = $1)
               ->  Materialize
                     ->  Nested Loop
                           ->  Nested Loop
                                 ->  Index Only Scan using t1_pkey on t1 t1_3
                                       Index Cond: (id = $1)
                                 ->  Seq Scan on t2 t2_3
                                       Filter: (id = $1)
                           ->  Seq Scan on t3 t3_3
                                 Filter: (id = $1)
 Optimizer: Postgres query optimizer
(62 rows)

-- no sure why can't leading the t1_1 t2_1 t3_1
/*+Leading(t1_1 t3_1)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
LOG:  statement: /*+Leading(t1_1 t3_1)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
LOG:  pg_hint_plan:
used hint:
Leading(t1_1 t3_1)
not used hint:
duplication hint:
error hint:
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $0)  (slice4)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice5; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1_2.id = t2_2.id)
                             ->  Seq Scan on t1 t1_2
                             ->  Hash
                                   ->  Hash Join
                                         Hash Cond: (t2_2.id = t3_2.id)
                                         ->  Seq Scan on t2 t2_2
                                         ->  Hash
                                               ->  Seq Scan on t3 t3_2
   InitPlan 2 (returns $1)  (slice6)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice7; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1_4.id = t2_4.id)
                             ->  Seq Scan on t1 t1_4
                             ->  Hash
                                   ->  Hash Join
                                         Hash Cond: (t2_4.id = t3_4.id)
                                         ->  Seq Scan on t2 t2_4
                                         ->  Hash
                                               ->  Seq Scan on t3 t3_4
   ->  Nested Loop
         ->  Redistribute Motion 1:3  (slice2; segments: 1)
               Hash Key: (max(t1_5.id))
               ->  Finalize Aggregate
                     Filter: (max(t1_5.id) = $1)
                     ->  Gather Motion 3:1  (slice3; segments: 3)
                           ->  Partial Aggregate
                                 ->  Hash Join
                                       Hash Cond: (t1_5.id = t2_5.id)
                                       ->  Seq Scan on t1 t1_5
                                       ->  Hash
                                             ->  Hash Join
                                                   Hash Cond: (t2_5.id = t3_5.id)
                                                   ->  Seq Scan on t2 t2_5
                                                   ->  Hash
                                                         ->  Seq Scan on t3 t3_5
         ->  Nested Loop
               ->  Nested Loop
                     ->  Nested Loop
                           ->  Index Only Scan using t1_pkey on t1 t1_1
                                 Index Cond: (id = $1)
                           ->  Seq Scan on t2 t2_1
                                 Filter: (id = $1)
                     ->  Seq Scan on t3 t3_1
                           Filter: (id = $1)
               ->  Materialize
                     ->  Nested Loop
                           ->  Nested Loop
                                 ->  Index Only Scan using t1_pkey on t1 t1_3
                                       Index Cond: (id = $1)
                                 ->  Seq Scan on t2 t2_3
                                       Filter: (id = $1)
                           ->  Seq Scan on t3 t3_3
                                 Filter: (id = $1)
 Optimizer: Postgres query optimizer
(62 rows)

/*+Leading(t1_4 t3_4)Leading(t1_2 t3_2)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
LOG:  statement: /*+Leading(t1_4 t3_4)Leading(t1_2 t3_2)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
LOG:  pg_hint_plan:
used hint:
Leading(t1_4 t3_4)
Leading(t1_2 t3_2)
not used hint:
duplication hint:
error hint:
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $1)  (slice4)
     ->  Aggregate
           ->  Gather Motion 3:1  (slice5; segments: 3)
                 ->  Nested Loop
                       ->  Hash Join
                             Hash Cond: (t1_2.id = t3_2.id)
                             ->  Seq Scan on t1 t1_2
                             ->  Hash
                                   ->  Seq Scan on t3 t3_2
                       ->  Index Only Scan using t2_pkey on t2 t2_2
                             Index Cond: (id = t1_2.id)
   InitPlan 2 (returns $3)  (slice6)
     ->  Aggregate
           ->  Gather Motion 3:1  (slice7; segments: 3)
                 ->  Nested Loop
                       ->  Hash Join
                             Hash Cond: (t1_4.id = t3_4.id)
                             ->  Seq Scan on t1 t1_4
                             ->  Hash
                                   ->  Seq Scan on t3 t3_4
                       ->  Index Only Scan using t2_pkey on t2 t2_4
                             Index Cond: (id = t1_4.id)
   ->  Nested Loop
         ->  Redistribute Motion 1:3  (slice2; segments: 1)
               Hash Key: (max(t1_5.id))
               ->  Finalize Aggregate
                     Filter: (max(t1_5.id) = $3)
                     ->  Gather Motion 3:1  (slice3; segments: 3)
                           ->  Partial Aggregate
                                 ->  Hash Join
                                       Hash Cond: (t1_5.id = t2_5.id)
                                       ->  Seq Scan on t1 t1_5
                                       ->  Hash
                                             ->  Hash Join
                                                   Hash Cond: (t2_5.id = t3_5.id)
                                                   ->  Seq Scan on t2 t2_5
                                                   ->  Hash
                                                         ->  Seq Scan on t3 t3_5
         ->  Nested Loop
               ->  Nested Loop
                     ->  Nested Loop
                           ->  Index Only Scan using t1_pkey on t1 t1_1
                                 Index Cond: (id = $3)
                           ->  Seq Scan on t2 t2_1
                                 Filter: (id = $3)
                     ->  Seq Scan on t3 t3_1
                           Filter: (id = $3)
               ->  Materialize
                     ->  Nested Loop
                           ->  Nested Loop
                                 ->  Index Only Scan using t1_pkey on t1 t1_3
                                       Index Cond: (id = $3)
                                 ->  Seq Scan on t2 t2_3
                                       Filter: (id = $3)
                           ->  Seq Scan on t3 t3_3
                                 Filter: (id = $3)
 Optimizer: Postgres query optimizer
(58 rows)

/*+IndexScan(t3_2)BitmapScan(t2_2)NestLoop(t2_2 t3_2)Leading(t2_2 t3_2)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
LOG:  statement: /*+IndexScan(t3_2)BitmapScan(t2_2)NestLoop(t2_2 t3_2)Leading(t2_2 t3_2)*/
EXPLAIN (COSTS false)
WITH c1_1(id) AS (
SELECT max(t1_5.id) FROM t1 t1_5, t2 t2_5, t3 t3_5 WHERE t1_5.id = t2_5.id AND t2_5.id = t3_5.id
)
SELECT t1_1.id, (
SELECT max(t1_2.id) FROM t1 t1_2, t2 t2_2, t3 t3_2 WHERE t1_2.id = t2_2.id AND t2_2.id = t3_2.id
) FROM t1 t1_1, t2 t2_1, t3 t3_1, (
SELECT t1_3.id FROM t1 t1_3, t2 t2_3, t3 t3_3 WHERE t1_3.id = t2_3.id AND t2_3.id = t3_3.id
) v1_1(id), c1_1 WHERE t1_1.id = t2_1.id AND t2_1.id = t3_1.id AND t2_1.id = v1_1.id AND v1_1.id = c1_1.id AND t1_1.id = (
SELECT max(t1_4.id) FROM t1 t1_4, t2 t2_4, t3 t3_4 WHERE t1_4.id = t2_4.id AND t2_4.id = t3_4.id 
);
LOG:  pg_hint_plan:
used hint:
BitmapScan(t2_2)
IndexScan(t3_2)
NestLoop(t2_2 t3_2)
Leading(t2_2 t3_2)
not used hint:
duplication hint:
error hint:
                                    QUERY PLAN                                    
----------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $2)  (slice4)
     ->  Aggregate
           ->  Gather Motion 3:1  (slice5; segments: 3)
                 ->  Nested Loop
                       ->  Nested Loop
                             ->  Bitmap Heap Scan on t2 t2_2
                                   ->  Bitmap Index Scan on t2_pkey
                             ->  Index Scan using t3_pkey on t3 t3_2
                                   Index Cond: (id = t2_2.id)
                       ->  Index Only Scan using t1_pkey on t1 t1_2
                             Index Cond: (id = t2_2.id)
   InitPlan 2 (returns $3)  (slice6)
     ->  Finalize Aggregate
           ->  Gather Motion 3:1  (slice7; segments: 3)
                 ->  Partial Aggregate
                       ->  Hash Join
                             Hash Cond: (t1_4.id = t2_4.id)
                             ->  Seq Scan on t1 t1_4
                             ->  Hash
                                   ->  Hash Join
                                         Hash Cond: (t2_4.id = t3_4.id)
                                         ->  Seq Scan on t2 t2_4
                                         ->  Hash
                                               ->  Seq Scan on t3 t3_4
   ->  Nested Loop
         ->  Redistribute Motion 1:3  (slice2; segments: 1)
               Hash Key: (max(t1_5.id))
               ->  Finalize Aggregate
                     Filter: (max(t1_5.id) = $3)
                     ->  Gather Motion 3:1  (slice3; segments: 3)
                           ->  Partial Aggregate
                                 ->  Hash Join
                                       Hash Cond: (t1_5.id = t2_5.id)
                                       ->  Seq Scan on t1 t1_5
                                       ->  Hash
                                             ->  Hash Join
                                                   Hash Cond: (t2_5.id = t3_5.id)
                                                   ->  Seq Scan on t2 t2_5
                                                   ->  Hash
                                                         ->  Seq Scan on t3 t3_5
         ->  Nested Loop
               ->  Nested Loop
                     ->  Nested Loop
                           ->  Index Only Scan using t1_pkey on t1 t1_1
                                 Index Cond: (id = $3)
                           ->  Seq Scan on t2 t2_1
                                 Filter: (id = $3)
                     ->  Seq Scan on t3 t3_1
                           Filter: (id = $3)
               ->  Materialize
                     ->  Nested Loop
                           ->  Nested Loop
                                 ->  Index Only Scan using t1_pkey on t1 t1_3
                                       Index Cond: (id = $3)
                                 ->  Seq Scan on t2 t2_3
                                       Filter: (id = $3)
                           ->  Seq Scan on t3 t3_3
                                 Filter: (id = $3)
 Optimizer: Postgres query optimizer
(60 rows)

-- ambigous error
EXPLAIN (COSTS false) SELECT * FROM t1, s0.t1, t2 WHERE public.t1.id = s0.t1.id AND public.t1.id = t2.id;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, s0.t1, t2 WHERE public.t1.id = s0.t1.id AND public.t1.id = t2.id;
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t1_1.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t1_1.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Seq Scan on t1 t1_1
 Optimizer: Postgres query optimizer
(11 rows)

/*+NestLoop(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, s0.t1, t2 WHERE public.t1.id = s0.t1.id AND public.t1.id = t2.id;
LOG:  statement: /*+NestLoop(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, s0.t1, t2 WHERE public.t1.id = s0.t1.id AND public.t1.id = t2.id;
INFO:  pg_hint_plan: hint syntax error at or near "NestLoop(t1 t2)"
DETAIL:  Relation name "t1" is ambiguous.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
NestLoop(t1 t2)
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t1_1.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t1_1.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Seq Scan on t1 t1_1
 Optimizer: Postgres query optimizer
(11 rows)

/*+Leading(t1 t2 t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, s0.t1, t2 WHERE public.t1.id = s0.t1.id AND public.t1.id = t2.id;
LOG:  statement: /*+Leading(t1 t2 t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1, s0.t1, t2 WHERE public.t1.id = s0.t1.id AND public.t1.id = t2.id;
INFO:  pg_hint_plan: hint syntax error at or near "Leading(t1 t2 t1)"
DETAIL:  Relation name "t1" is ambiguous.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Leading(t1 t2 t1)
                    QUERY PLAN                     
---------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t1_1.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t1_1.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Seq Scan on t1 t1_1
 Optimizer: Postgres query optimizer
(11 rows)

-- identifier length test
EXPLAIN (COSTS false) SELECT * FROM t1 "123456789012345678901234567890123456789012345678901234567890123" JOIN t2 ON ("123456789012345678901234567890123456789012345678901234567890123".id = t2.id) JOIN t3 ON (t2.id = t3.id);
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1 "123456789012345678901234567890123456789012345678901234567890123" JOIN t2 ON ("123456789012345678901234567890123456789012345678901234567890123".id = t2.id) JOIN t3 ON (t2.id = t3.id);
                                            QUERY PLAN                                             
---------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: ("123456789012345678901234567890123456789012345678901234567890123".id = t2.id)
         ->  Seq Scan on t1 "123456789012345678901234567890123456789012345678901234567890123"
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t3.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(11 rows)

/*+
Leading(123456789012345678901234567890123456789012345678901234567890123 t2 t3)
SeqScan(123456789012345678901234567890123456789012345678901234567890123)
MergeJoin(123456789012345678901234567890123456789012345678901234567890123 t2)
Set(123456789012345678901234567890123456789012345678901234567890123 1)
*/
EXPLAIN (COSTS false) SELECT * FROM t1 "123456789012345678901234567890123456789012345678901234567890123" JOIN t2 ON ("123456789012345678901234567890123456789012345678901234567890123".id = t2.id) JOIN t3 ON (t2.id = t3.id);
LOG:  statement: /*+
Leading(123456789012345678901234567890123456789012345678901234567890123 t2 t3)
SeqScan(123456789012345678901234567890123456789012345678901234567890123)
MergeJoin(123456789012345678901234567890123456789012345678901234567890123 t2)
Set(123456789012345678901234567890123456789012345678901234567890123 1)
*/
EXPLAIN (COSTS false) SELECT * FROM t1 "123456789012345678901234567890123456789012345678901234567890123" JOIN t2 ON ("123456789012345678901234567890123456789012345678901234567890123".id = t2.id) JOIN t3 ON (t2.id = t3.id);
INFO:  unrecognized configuration parameter "123456789012345678901234567890123456789012345678901234567890123"
LOG:  pg_hint_plan:
used hint:
SeqScan(123456789012345678901234567890123456789012345678901234567890123)
MergeJoin(123456789012345678901234567890123456789012345678901234567890123 t2)
Leading(123456789012345678901234567890123456789012345678901234567890123 t2 t3)
not used hint:
duplication hint:
error hint:
Set(123456789012345678901234567890123456789012345678901234567890123 1)
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: ("123456789012345678901234567890123456789012345678901234567890123".id = t3.id)
         ->  Merge Join
               Merge Cond: ("123456789012345678901234567890123456789012345678901234567890123".id = t2.id)
               ->  Sort
                     Sort Key: "123456789012345678901234567890123456789012345678901234567890123".id
                     ->  Seq Scan on t1 "123456789012345678901234567890123456789012345678901234567890123"
               ->  Sort
                     Sort Key: t2.id
                     ->  Seq Scan on t2
         ->  Hash
               ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(14 rows)

/*+
Leading(1234567890123456789012345678901234567890123456789012345678901234 t2 t3)
SeqScan(1234567890123456789012345678901234567890123456789012345678901234)
MergeJoin(1234567890123456789012345678901234567890123456789012345678901234 t2)
Set(1234567890123456789012345678901234567890123456789012345678901234 1)
Set(cursor_tuple_fraction 0.1234567890123456789012345678901234567890123456789012345678901234)
*/
EXPLAIN (COSTS false) SELECT * FROM t1 "1234567890123456789012345678901234567890123456789012345678901234" JOIN t2 ON ("1234567890123456789012345678901234567890123456789012345678901234".id = t2.id) JOIN t3 ON (t2.id = t3.id);
NOTICE:  identifier "1234567890123456789012345678901234567890123456789012345678901234" will be truncated to "123456789012345678901234567890123456789012345678901234567890123"
NOTICE:  identifier "1234567890123456789012345678901234567890123456789012345678901234" will be truncated to "123456789012345678901234567890123456789012345678901234567890123"
LOG:  statement: /*+
Leading(1234567890123456789012345678901234567890123456789012345678901234 t2 t3)
SeqScan(1234567890123456789012345678901234567890123456789012345678901234)
MergeJoin(1234567890123456789012345678901234567890123456789012345678901234 t2)
Set(1234567890123456789012345678901234567890123456789012345678901234 1)
Set(cursor_tuple_fraction 0.1234567890123456789012345678901234567890123456789012345678901234)
*/
EXPLAIN (COSTS false) SELECT * FROM t1 "1234567890123456789012345678901234567890123456789012345678901234" JOIN t2 ON ("1234567890123456789012345678901234567890123456789012345678901234".id = t2.id) JOIN t3 ON (t2.id = t3.id);
NOTICE:  identifier "1234567890123456789012345678901234567890123456789012345678901234" will be truncated to "123456789012345678901234567890123456789012345678901234567890123"
NOTICE:  identifier "1234567890123456789012345678901234567890123456789012345678901234" will be truncated to "123456789012345678901234567890123456789012345678901234567890123"
NOTICE:  identifier "1234567890123456789012345678901234567890123456789012345678901234" will be truncated to "123456789012345678901234567890123456789012345678901234567890123"
NOTICE:  identifier "1234567890123456789012345678901234567890123456789012345678901234" will be truncated to "123456789012345678901234567890123456789012345678901234567890123"
INFO:  unrecognized configuration parameter "123456789012345678901234567890123456789012345678901234567890123"
LOG:  pg_hint_plan:
used hint:
SeqScan(123456789012345678901234567890123456789012345678901234567890123)
MergeJoin(123456789012345678901234567890123456789012345678901234567890123 t2)
Leading(123456789012345678901234567890123456789012345678901234567890123 t2 t3)
Set(cursor_tuple_fraction 0.1234567890123456789012345678901234567890123456789012345678901234)
not used hint:
duplication hint:
error hint:
Set(123456789012345678901234567890123456789012345678901234567890123 1)
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: ("123456789012345678901234567890123456789012345678901234567890123".id = t3.id)
         ->  Merge Join
               Merge Cond: ("123456789012345678901234567890123456789012345678901234567890123".id = t2.id)
               ->  Sort
                     Sort Key: "123456789012345678901234567890123456789012345678901234567890123".id
                     ->  Seq Scan on t1 "123456789012345678901234567890123456789012345678901234567890123"
               ->  Sort
                     Sort Key: t2.id
                     ->  Seq Scan on t2
         ->  Hash
               ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(14 rows)

SET "123456789012345678901234567890123456789012345678901234567890123" TO 1;
LOG:  statement: SET "123456789012345678901234567890123456789012345678901234567890123" TO 1;
LOG:  An exception was encountered during the execution of statement: SET "123456789012345678901234567890123456789012345678901234567890123" TO 1;
ERROR:  unrecognized configuration parameter "123456789012345678901234567890123456789012345678901234567890123"
SET "1234567890123456789012345678901234567890123456789012345678901234" TO 1;
NOTICE:  identifier "1234567890123456789012345678901234567890123456789012345678901234" will be truncated to "123456789012345678901234567890123456789012345678901234567890123"
LOG:  statement: SET "1234567890123456789012345678901234567890123456789012345678901234" TO 1;
LOG:  An exception was encountered during the execution of statement: SET "1234567890123456789012345678901234567890123456789012345678901234" TO 1;
ERROR:  unrecognized configuration parameter "123456789012345678901234567890123456789012345678901234567890123"
SET cursor_tuple_fraction TO 1234567890123456789012345678901234567890123456789012345678901234;
LOG:  statement: SET cursor_tuple_fraction TO 1234567890123456789012345678901234567890123456789012345678901234;
LOG:  An exception was encountered during the execution of statement: SET cursor_tuple_fraction TO 1234567890123456789012345678901234567890123456789012345678901234;
ERROR:  1.23457e+63 is outside the valid range for parameter "cursor_tuple_fraction" (0 .. 1)
-- multi error
/*+ Set(enable_seqscan 100)Set(seq_page_cost on)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
LOG:  statement: /*+ Set(enable_seqscan 100)Set(seq_page_cost on)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id;
INFO:  parameter "enable_seqscan" requires a Boolean value
INFO:  invalid value for parameter "seq_page_cost": "on"
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Set(enable_seqscan 100)
Set(seq_page_cost on)
                QUERY PLAN                
------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(7 rows)

-- debug log of candidate index to use IndexScan
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Index Scan using t5_idaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa on t5
         Index Cond: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

/*+IndexScan(t5 t5_id2)*/
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  statement: /*+IndexScan(t5 t5_id2)*/
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  available indexes for IndexScan(t5):
LOG:  pg_hint_plan:
used hint:
IndexScan(t5 t5_id2)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Index Scan using t5_id2 on t5
         Index Cond: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

/*+IndexScan(t5 no_exist)*/
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  statement: /*+IndexScan(t5 no_exist)*/
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  available indexes for IndexScan(t5):
LOG:  pg_hint_plan:
used hint:
IndexScan(t5 no_exist)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Index Scan using t5_id2 on t5
         Index Cond: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

/*+IndexScan(t5 t5_id1 t5_id2)*/
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  statement: /*+IndexScan(t5 t5_id1 t5_id2)*/
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  available indexes for IndexScan(t5): t5_id1
LOG:  pg_hint_plan:
used hint:
IndexScan(t5 t5_id1 t5_id2)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Index Scan using t5_id2 on t5
         Index Cond: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

/*+IndexScan(t5 no_exist t5_id2)*/
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  statement: /*+IndexScan(t5 no_exist t5_id2)*/
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  available indexes for IndexScan(t5):
LOG:  pg_hint_plan:
used hint:
IndexScan(t5 no_exist t5_id2)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Index Scan using t5_id2 on t5
         Index Cond: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

/*+IndexScan(t5 no_exist5 no_exist2)*/
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  statement: /*+IndexScan(t5 no_exist5 no_exist2)*/
EXPLAIN (COSTS false) SELECT * FROM t5 WHERE t5.id = 1;
LOG:  available indexes for IndexScan(t5):
LOG:  pg_hint_plan:
used hint:
IndexScan(t5 no_exist5 no_exist2)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Index Scan using t5_id2 on t5
         Index Cond: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

-- outer inner
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t3.val = t2.val)
         ->  Seq Scan on t3
         ->  Hash
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Hash Join
                           Hash Cond: (t1.id = t2.id)
                           ->  Index Scan using t1_pkey on t1
                                 Index Cond: (id < 10)
                           ->  Hash
                                 ->  Seq Scan on t2
                                       Filter: (id < 10)
 Optimizer: Postgres query optimizer
(14 rows)

/*+Leading((t1))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading((t1))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
INFO:  pg_hint_plan: hint syntax error at or near "Leading((t1))"
DETAIL:  Leading hint requires two sets of relations when parentheses nests.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Leading((t1))
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t3.val = t2.val)
         ->  Seq Scan on t3
         ->  Hash
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Hash Join
                           Hash Cond: (t1.id = t2.id)
                           ->  Index Scan using t1_pkey on t1
                                 Index Cond: (id < 10)
                           ->  Hash
                                 ->  Seq Scan on t2
                                       Filter: (id < 10)
 Optimizer: Postgres query optimizer
(14 rows)

/*+Leading((t1 t2))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading((t1 t2))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading((t1 t2))
not used hint:
duplication hint:
error hint:
                       QUERY PLAN                        
---------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         Join Filter: (t2.val = t3.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Index Scan using t1_pkey on t1
                           Index Cond: (id < 10)
                     ->  Hash
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
         ->  Materialize
               ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(14 rows)

/*+Leading((t1 t2 t3))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading((t1 t2 t3))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
INFO:  pg_hint_plan: hint syntax error at or near "Leading((t1 t2 t3))"
DETAIL:  Leading hint requires two sets of relations when parentheses nests.
LOG:  pg_hint_plan:
used hint:
not used hint:
duplication hint:
error hint:
Leading((t1 t2 t3))
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t3.val = t2.val)
         ->  Seq Scan on t3
         ->  Hash
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Hash Join
                           Hash Cond: (t1.id = t2.id)
                           ->  Index Scan using t1_pkey on t1
                                 Index Cond: (id < 10)
                           ->  Hash
                                 ->  Seq Scan on t2
                                       Filter: (id < 10)
 Optimizer: Postgres query optimizer
(14 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.id < 10;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.id < 10;
                 QUERY PLAN                 
--------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id < 10)
         ->  Hash
               ->  Seq Scan on t2
                     Filter: (id < 10)
 Optimizer: Postgres query optimizer
(9 rows)

/*+Leading((t1 t2))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.id < 10;
LOG:  statement: /*+Leading((t1 t2))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2 WHERE t1.id = t2.id AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading((t1 t2))
not used hint:
duplication hint:
error hint:
                 QUERY PLAN                 
--------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id < 10)
         ->  Hash
               ->  Seq Scan on t2
                     Filter: (id < 10)
 Optimizer: Postgres query optimizer
(9 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t3.val = t2.val)
         ->  Seq Scan on t3
         ->  Hash
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Hash Join
                           Hash Cond: (t1.id = t2.id)
                           ->  Index Scan using t1_pkey on t1
                                 Index Cond: (id < 10)
                           ->  Hash
                                 ->  Seq Scan on t2
                                       Filter: (id < 10)
 Optimizer: Postgres query optimizer
(14 rows)

/*+Leading(((t1 t2) t3))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading(((t1 t2) t3))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) t3))
not used hint:
duplication hint:
error hint:
                       QUERY PLAN                        
---------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.val = t3.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Index Scan using t1_pkey on t1
                           Index Cond: (id < 10)
                     ->  Hash
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
         ->  Hash
               ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(14 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
                       QUERY PLAN                        
---------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.val = t3.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Index Scan using t1_pkey on t1
                           Index Cond: (id < 10)
                     ->  Hash
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t3.id = t4.id)
                     ->  Seq Scan on t3
                     ->  Hash
                           ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(18 rows)

/*+Leading((((t1 t2) t3) t4))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading((((t1 t2) t3) t4))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading((((t1 t2) t3) t4))
not used hint:
duplication hint:
error hint:
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t3.id = t4.id)
         ->  Hash Join
               Hash Cond: (t1.val = t3.val)
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Hash Join
                           Hash Cond: (t1.id = t2.id)
                           ->  Index Scan using t1_pkey on t1
                                 Index Cond: (id < 10)
                           ->  Hash
                                 ->  Seq Scan on t2
                                       Filter: (id < 10)
               ->  Hash
                     ->  Seq Scan on t3
         ->  Hash
               ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(18 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t3.val = t2.val)
         ->  Seq Scan on t3
         ->  Hash
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Hash Join
                           Hash Cond: (t1.id = t2.id)
                           ->  Index Scan using t1_pkey on t1
                                 Index Cond: (id < 10)
                           ->  Hash
                                 ->  Seq Scan on t2
                                       Filter: (id < 10)
 Optimizer: Postgres query optimizer
(14 rows)

/*+Leading(((t1 t2) t3))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading(((t1 t2) t3))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) t3))
not used hint:
duplication hint:
error hint:
                       QUERY PLAN                        
---------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.val = t3.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Index Scan using t1_pkey on t1
                           Index Cond: (id < 10)
                     ->  Hash
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
         ->  Hash
               ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(14 rows)

/*+Leading((t1 (t2 t3)))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading((t1 (t2 t3)))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading((t1 (t2 t3)))
not used hint:
duplication hint:
error hint:
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id < 10)
         ->  Hash
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Hash Key: t2.id
                     ->  Hash Join
                           Hash Cond: (t2.val = t3.val)
                           ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                 ->  Seq Scan on t2
                                       Filter: (id < 10)
                           ->  Hash
                                 ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(16 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
                       QUERY PLAN                        
---------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.val = t3.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Index Scan using t1_pkey on t1
                           Index Cond: (id < 10)
                     ->  Hash
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t3.id = t4.id)
                     ->  Seq Scan on t3
                     ->  Hash
                           ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(18 rows)

/*+Leading(((t1 t2) (t3 t4)))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading(((t1 t2) (t3 t4)))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) (t3 t4)))
not used hint:
duplication hint:
error hint:
                       QUERY PLAN                        
---------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.val = t3.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Index Scan using t1_pkey on t1
                           Index Cond: (id < 10)
                     ->  Hash
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t3.id = t4.id)
                     ->  Seq Scan on t3
                     ->  Hash
                           ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(18 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < ( SELECT t1_2.id FROM t1 t1_2, t2 t2_2 WHERE t1_2.id = t2_2.id AND t2_2.val > 100 ORDER BY t1_2.id LIMIT 1);
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < ( SELECT t1_2.id FROM t1 t1_2, t2 t2_2 WHERE t1_2.id = t2_2.id AND t2_2.val > 100 ORDER BY t1_2.id LIMIT 1);
                            QUERY PLAN                             
-------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $0)  (slice3)
     ->  Limit
           ->  Gather Motion 3:1  (slice4; segments: 3)
                 Merge Key: t1_2.id
                 ->  Limit
                       ->  Sort
                             Sort Key: t1_2.id
                             ->  Hash Join
                                   Hash Cond: (t1_2.id = t2_2.id)
                                   ->  Seq Scan on t1 t1_2
                                   ->  Hash
                                         ->  Seq Scan on t2 t2_2
                                               Filter: (val > 100)
   ->  Hash Join
         Hash Cond: (t3.val = t2.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Seq Scan on t3
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Seq Scan on t1
                           Filter: (id < $0)
                     ->  Hash
                           ->  Seq Scan on t2
                                 Filter: (id < $0)
 Optimizer: Postgres query optimizer
(27 rows)

/*+Leading(((t1 t2) t3)) Leading(((t3 t1) t2))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t1.val = t3.val AND t1.id < ( SELECT t1_2.id FROM t1 t1_2, t2 t2_2 WHERE t1_2.id = t2_2.id AND t2_2.val > 100 ORDER BY t1_2.id LIMIT 1);
LOG:  statement: /*+Leading(((t1 t2) t3)) Leading(((t3 t1) t2))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t1.val = t3.val AND t1.id < ( SELECT t1_2.id FROM t1 t1_2, t2 t2_2 WHERE t1_2.id = t2_2.id AND t2_2.val > 100 ORDER BY t1_2.id LIMIT 1);
INFO:  pg_hint_plan: hint syntax error at or near "Leading(((t1 t2) t3)) Leading(((t3 t1) t2))"
DETAIL:  Conflict leading hint.
LOG:  pg_hint_plan:
used hint:
Leading(((t3 t1) t2))
not used hint:
duplication hint:
Leading(((t1 t2) t3))
error hint:
                            QUERY PLAN                             
-------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $0)  (slice3)
     ->  Limit
           ->  Gather Motion 3:1  (slice4; segments: 3)
                 Merge Key: t1_2.id
                 ->  Limit
                       ->  Sort
                             Sort Key: t1_2.id
                             ->  Hash Join
                                   Hash Cond: (t1_2.id = t2_2.id)
                                   ->  Seq Scan on t1 t1_2
                                   ->  Hash
                                         ->  Seq Scan on t2 t2_2
                                               Filter: (val > 100)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Hash Join
               Hash Cond: (t3.val = t1.val)
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t3
               ->  Hash
                     ->  Seq Scan on t1
                           Filter: (id < $0)
         ->  Hash
               ->  Seq Scan on t2
                     Filter: (id < $0)
 Optimizer: Postgres query optimizer
(27 rows)

/*+Leading(((t1 t2) t3)) Leading((t1_2 t2_2))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < ( SELECT t1_2.id FROM t1 t1_2, t2 t2_2 WHERE t1_2.id = t2_2.id AND t2_2.val > 100 ORDER BY t1_2.id LIMIT 1);
LOG:  statement: /*+Leading(((t1 t2) t3)) Leading((t1_2 t2_2))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < ( SELECT t1_2.id FROM t1 t1_2, t2 t2_2 WHERE t1_2.id = t2_2.id AND t2_2.val > 100 ORDER BY t1_2.id LIMIT 1);
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) t3))
Leading((t1_2 t2_2))
not used hint:
duplication hint:
error hint:
                            QUERY PLAN                             
-------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $0)  (slice3)
     ->  Limit
           ->  Gather Motion 3:1  (slice4; segments: 3)
                 Merge Key: t1_2.id
                 ->  Limit
                       ->  Sort
                             Sort Key: t1_2.id
                             ->  Hash Join
                                   Hash Cond: (t1_2.id = t2_2.id)
                                   ->  Seq Scan on t1 t1_2
                                   ->  Hash
                                         ->  Seq Scan on t2 t2_2
                                               Filter: (val > 100)
   ->  Hash Join
         Hash Cond: (t2.val = t3.val)
         ->  Hash Join
               Hash Cond: (t1.id = t2.id)
               ->  Seq Scan on t1
                     Filter: (id < $0)
               ->  Hash
                     ->  Seq Scan on t2
                           Filter: (id < $0)
         ->  Hash
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(27 rows)

/*+Leading(((((t1 t2) t3) t1_2) t2_2))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < ( SELECT t1_2.id FROM t1 t1_2, t2 t2_2 WHERE t1_2.id = t2_2.id AND t2_2.val > 100 ORDER BY t1_2.id LIMIT 1);
LOG:  statement: /*+Leading(((((t1 t2) t3) t1_2) t2_2))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < ( SELECT t1_2.id FROM t1 t1_2, t2 t2_2 WHERE t1_2.id = t2_2.id AND t2_2.val > 100 ORDER BY t1_2.id LIMIT 1);
LOG:  pg_hint_plan:
used hint:
not used hint:
Leading(((((t1 t2) t3) t1_2) t2_2))
duplication hint:
error hint:
                            QUERY PLAN                             
-------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   InitPlan 1 (returns $0)  (slice3)
     ->  Limit
           ->  Gather Motion 3:1  (slice4; segments: 3)
                 Merge Key: t1_2.id
                 ->  Limit
                       ->  Sort
                             Sort Key: t1_2.id
                             ->  Hash Join
                                   Hash Cond: (t1_2.id = t2_2.id)
                                   ->  Seq Scan on t1 t1_2
                                   ->  Hash
                                         ->  Seq Scan on t2 t2_2
                                               Filter: (val > 100)
   ->  Hash Join
         Hash Cond: (t3.val = t2.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Seq Scan on t3
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Seq Scan on t1
                           Filter: (id < $0)
                     ->  Hash
                           ->  Seq Scan on t2
                                 Filter: (id < $0)
 Optimizer: Postgres query optimizer
(27 rows)

-- Specified outer/inner leading hint and join method hint at the same time
/*+Leading(((t1 t2) t3))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading(((t1 t2) t3))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) t3))
not used hint:
duplication hint:
error hint:
                       QUERY PLAN                        
---------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.val = t3.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Index Scan using t1_pkey on t1
                           Index Cond: (id < 10)
                     ->  Hash
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
         ->  Hash
               ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(14 rows)

/*+Leading(((t1 t2) t3)) MergeJoin(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading(((t1 t2) t3)) MergeJoin(t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
MergeJoin(t1 t2)
Leading(((t1 t2) t3))
not used hint:
duplication hint:
error hint:
                       QUERY PLAN                        
---------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.val = t3.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Merge Join
                     Merge Cond: (t1.id = t2.id)
                     ->  Index Scan using t1_pkey on t1
                           Index Cond: (id < 10)
                     ->  Sort
                           Sort Key: t2.id
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
         ->  Hash
               ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(15 rows)

/*+Leading(((t1 t2) t3)) MergeJoin(t1 t2 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading(((t1 t2) t3)) MergeJoin(t1 t2 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
MergeJoin(t1 t2 t3)
Leading(((t1 t2) t3))
not used hint:
duplication hint:
error hint:
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Join
         Merge Cond: (t2.val = t3.val)
         ->  Sort
               Sort Key: t2.val
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Hash Join
                           Hash Cond: (t1.id = t2.id)
                           ->  Index Scan using t1_pkey on t1
                                 Index Cond: (id < 10)
                           ->  Hash
                                 ->  Seq Scan on t2
                                       Filter: (id < 10)
         ->  Sort
               Sort Key: t3.val
               ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(17 rows)

/*+Leading(((t1 t2) t3)) MergeJoin(t1 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading(((t1 t2) t3)) MergeJoin(t1 t3)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) t3))
not used hint:
MergeJoin(t1 t3)
duplication hint:
error hint:
                       QUERY PLAN                        
---------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.val = t3.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Index Scan using t1_pkey on t1
                           Index Cond: (id < 10)
                     ->  Hash
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
         ->  Hash
               ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(14 rows)

EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
                       QUERY PLAN                        
---------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.val = t3.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Index Scan using t1_pkey on t1
                           Index Cond: (id < 10)
                     ->  Hash
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t3.id = t4.id)
                     ->  Seq Scan on t3
                     ->  Hash
                           ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(18 rows)

/*+Leading(((t1 t2) t3)) MergeJoin(t3 t4)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading(((t1 t2) t3)) MergeJoin(t3 t4)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) t3))
not used hint:
MergeJoin(t3 t4)
duplication hint:
error hint:
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Hash Join
               Hash Cond: (t1.val = t3.val)
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Hash Join
                           Hash Cond: (t1.id = t2.id)
                           ->  Index Scan using t1_pkey on t1
                                 Index Cond: (id < 10)
                           ->  Hash
                                 ->  Seq Scan on t2
                                       Filter: (id < 10)
               ->  Hash
                     ->  Seq Scan on t3
         ->  Index Scan using t4_pkey on t4
               Index Cond: (id = t3.id)
 Optimizer: Postgres query optimizer
(17 rows)

/*+Leading(((t1 t2) t3)) MergeJoin(t1 t2 t3 t4)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading(((t1 t2) t3)) MergeJoin(t1 t2 t3 t4)*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4 WHERE t1.id = t2.id AND t3.id = t4.id AND t1.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
MergeJoin(t1 t2 t3 t4)
Leading(((t1 t2) t3))
not used hint:
duplication hint:
error hint:
                             QUERY PLAN                              
---------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Join
         Merge Cond: (t3.id = t4.id)
         ->  Sort
               Sort Key: t3.id
               ->  Hash Join
                     Hash Cond: (t1.val = t3.val)
                     ->  Broadcast Motion 3:3  (slice2; segments: 3)
                           ->  Hash Join
                                 Hash Cond: (t1.id = t2.id)
                                 ->  Index Scan using t1_pkey on t1
                                       Index Cond: (id < 10)
                                 ->  Hash
                                       ->  Seq Scan on t2
                                             Filter: (id < 10)
                     ->  Hash
                           ->  Seq Scan on t3
         ->  Sort
               Sort Key: t4.id
               ->  Seq Scan on t4
 Optimizer: Postgres query optimizer
(21 rows)

/*+ Leading ( ( t1 ( t2 t3 ) ) ) */
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+ Leading ( ( t1 ( t2 t3 ) ) ) */
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading((t1 (t2 t3)))
not used hint:
duplication hint:
error hint:
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id < 10)
         ->  Hash
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Hash Key: t2.id
                     ->  Hash Join
                           Hash Cond: (t2.val = t3.val)
                           ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                 ->  Seq Scan on t2
                                       Filter: (id < 10)
                           ->  Hash
                                 ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(16 rows)

/*+Leading((t1(t2 t3)))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading((t1(t2 t3)))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading((t1 (t2 t3)))
not used hint:
duplication hint:
error hint:
                                QUERY PLAN                                 
---------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id < 10)
         ->  Hash
               ->  Redistribute Motion 3:3  (slice2; segments: 3)
                     Hash Key: t2.id
                     ->  Hash Join
                           Hash Cond: (t2.val = t3.val)
                           ->  Broadcast Motion 3:3  (slice3; segments: 3)
                                 ->  Seq Scan on t2
                                       Filter: (id < 10)
                           ->  Hash
                                 ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(16 rows)

/*+Leading(("t1(t2" "t3)"))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading(("t1(t2" "t3)"))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
not used hint:
Leading(("t1(t2" "t3)"))
duplication hint:
error hint:
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t3.val = t2.val)
         ->  Seq Scan on t3
         ->  Hash
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Hash Join
                           Hash Cond: (t1.id = t2.id)
                           ->  Index Scan using t1_pkey on t1
                                 Index Cond: (id < 10)
                           ->  Hash
                                 ->  Seq Scan on t2
                                       Filter: (id < 10)
 Optimizer: Postgres query optimizer
(14 rows)

/*+ Leading ( ( ( t1 t2 ) t3 ) ) */
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+ Leading ( ( ( t1 t2 ) t3 ) ) */
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) t3))
not used hint:
duplication hint:
error hint:
                       QUERY PLAN                        
---------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.val = t3.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Index Scan using t1_pkey on t1
                           Index Cond: (id < 10)
                     ->  Hash
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
         ->  Hash
               ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(14 rows)

/*+Leading(((t1 t2)t3))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading(((t1 t2)t3))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) t3))
not used hint:
duplication hint:
error hint:
                       QUERY PLAN                        
---------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.val = t3.val)
         ->  Broadcast Motion 3:3  (slice2; segments: 3)
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Index Scan using t1_pkey on t1
                           Index Cond: (id < 10)
                     ->  Hash
                           ->  Seq Scan on t2
                                 Filter: (id < 10)
         ->  Hash
               ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(14 rows)

/*+Leading(("(t1" "t2)t3"))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  statement: /*+Leading(("(t1" "t2)t3"))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3 WHERE t1.id = t2.id AND t2.val = t3.val AND t1.id < 10;
LOG:  pg_hint_plan:
used hint:
not used hint:
Leading(("(t1" "t2)t3"))
duplication hint:
error hint:
                          QUERY PLAN                           
---------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t3.val = t2.val)
         ->  Seq Scan on t3
         ->  Hash
               ->  Broadcast Motion 3:3  (slice2; segments: 3)
                     ->  Hash Join
                           Hash Cond: (t1.id = t2.id)
                           ->  Index Scan using t1_pkey on t1
                                 Index Cond: (id < 10)
                           ->  Hash
                                 ->  Seq Scan on t2
                                       Filter: (id < 10)
 Optimizer: Postgres query optimizer
(14 rows)

/*+Leading((t1(t2(t3(t4 t5)))))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  statement: /*+Leading((t1(t2(t3(t4 t5)))))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  pg_hint_plan:
used hint:
Leading((t1 (t2 (t3 (t4 t5)))))
not used hint:
duplication hint:
error hint:
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Seq Scan on t1
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t3.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t3.id = t4.id)
                                 ->  Seq Scan on t3
                                 ->  Hash
                                       ->  Hash Join
                                             Hash Cond: (t4.id = t5.id)
                                             ->  Seq Scan on t4
                                             ->  Hash
                                                   ->  Seq Scan on t5
 Optimizer: Postgres query optimizer
(19 rows)

/*+Leading((t5(t4(t3(t2 t1)))))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  statement: /*+Leading((t5(t4(t3(t2 t1)))))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  pg_hint_plan:
used hint:
Leading((t5 (t4 (t3 (t2 t1)))))
not used hint:
duplication hint:
error hint:
                               QUERY PLAN                               
------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t5.id = t1.id)
         ->  Seq Scan on t5
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t4.id = t1.id)
                     ->  Seq Scan on t4
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t3.id = t1.id)
                                 ->  Seq Scan on t3
                                 ->  Hash
                                       ->  Hash Join
                                             Hash Cond: (t2.id = t1.id)
                                             ->  Seq Scan on t2
                                             ->  Hash
                                                   ->  Seq Scan on t1
 Optimizer: Postgres query optimizer
(19 rows)

/*+Leading(((((t1 t2)t3)t4)t5))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  statement: /*+Leading(((((t1 t2)t3)t4)t5))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  pg_hint_plan:
used hint:
Leading(((((t1 t2) t3) t4) t5))
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t5.id)
         ->  Hash Join
               Hash Cond: (t1.id = t4.id)
               ->  Hash Join
                     Hash Cond: (t1.id = t3.id)
                     ->  Hash Join
                           Hash Cond: (t1.id = t2.id)
                           ->  Seq Scan on t1
                           ->  Hash
                                 ->  Seq Scan on t2
                     ->  Hash
                           ->  Seq Scan on t3
               ->  Hash
                     ->  Seq Scan on t4
         ->  Hash
               ->  Seq Scan on t5
 Optimizer: Postgres query optimizer
(19 rows)

/*+Leading(((((t5 t4)t3)t2)t1))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  statement: /*+Leading(((((t5 t4)t3)t2)t1))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  pg_hint_plan:
used hint:
Leading(((((t5 t4) t3) t2) t1))
not used hint:
duplication hint:
error hint:
                      QUERY PLAN                      
------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Hash Join
               Hash Cond: (t3.id = t2.id)
               ->  Hash Join
                     Hash Cond: (t4.id = t3.id)
                     ->  Hash Join
                           Hash Cond: (t5.id = t4.id)
                           ->  Seq Scan on t5
                           ->  Hash
                                 ->  Seq Scan on t4
                     ->  Hash
                           ->  Seq Scan on t3
               ->  Hash
                     ->  Seq Scan on t2
         ->  Hash
               ->  Seq Scan on t1
 Optimizer: Postgres query optimizer
(19 rows)

/*+Leading(((t1 t2)(t3(t4 t5))))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  statement: /*+Leading(((t1 t2)(t3(t4 t5))))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  pg_hint_plan:
used hint:
Leading(((t1 t2) (t3 (t4 t5))))
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t3.id)
         ->  Hash Join
               Hash Cond: (t1.id = t2.id)
               ->  Seq Scan on t1
               ->  Hash
                     ->  Seq Scan on t2
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t3.id = t4.id)
                     ->  Seq Scan on t3
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t4.id = t5.id)
                                 ->  Seq Scan on t4
                                 ->  Hash
                                       ->  Seq Scan on t5
 Optimizer: Postgres query optimizer
(19 rows)

/*+Leading(((t5 t4)(t3(t2 t1))))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  statement: /*+Leading(((t5 t4)(t3(t2 t1))))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  pg_hint_plan:
used hint:
Leading(((t5 t4) (t3 (t2 t1))))
not used hint:
duplication hint:
error hint:
                         QUERY PLAN                         
------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t4.id = t1.id)
         ->  Hash Join
               Hash Cond: (t5.id = t4.id)
               ->  Seq Scan on t5
               ->  Hash
                     ->  Seq Scan on t4
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t3.id = t1.id)
                     ->  Seq Scan on t3
                     ->  Hash
                           ->  Hash Join
                                 Hash Cond: (t2.id = t1.id)
                                 ->  Seq Scan on t2
                                 ->  Hash
                                       ->  Seq Scan on t1
 Optimizer: Postgres query optimizer
(19 rows)

/*+Leading((((t1 t2)t3)(t4 t5)))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  statement: /*+Leading((((t1 t2)t3)(t4 t5)))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  pg_hint_plan:
used hint:
Leading((((t1 t2) t3) (t4 t5)))
not used hint:
duplication hint:
error hint:
                   QUERY PLAN                   
------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t4.id)
         ->  Hash Join
               Hash Cond: (t1.id = t3.id)
               ->  Hash Join
                     Hash Cond: (t1.id = t2.id)
                     ->  Seq Scan on t1
                     ->  Hash
                           ->  Seq Scan on t2
               ->  Hash
                     ->  Seq Scan on t3
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t4.id = t5.id)
                     ->  Seq Scan on t4
                     ->  Hash
                           ->  Seq Scan on t5
 Optimizer: Postgres query optimizer
(19 rows)

/*+Leading((((t5 t4)t3)(t2 t1)))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  statement: /*+Leading((((t5 t4)t3)(t2 t1)))*/
EXPLAIN (COSTS false) SELECT * FROM t1, t2, t3, t4, t5 WHERE t1.id = t2.id AND t1.id = t3.id AND t1.id = t4.id AND t1.id = t5.id;
LOG:  pg_hint_plan:
used hint:
Leading((((t5 t4) t3) (t2 t1)))
not used hint:
duplication hint:
error hint:
                   QUERY PLAN                   
------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t3.id = t1.id)
         ->  Hash Join
               Hash Cond: (t4.id = t3.id)
               ->  Hash Join
                     Hash Cond: (t5.id = t4.id)
                     ->  Seq Scan on t5
                     ->  Hash
                           ->  Seq Scan on t4
               ->  Hash
                     ->  Seq Scan on t3
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = t1.id)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Seq Scan on t1
 Optimizer: Postgres query optimizer
(19 rows)

-- inherite table test to specify the index's name
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p2.ctid" without the necessary companion column "p2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p2 p2_1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1 p2_2
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1_c1 p2_3
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1_c2 p2_4
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(11 rows)

/*+IndexScan(p2_c1 p2_c1_id2_val)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
LOG:  statement: /*+IndexScan(p2_c1 p2_c1_id2_val)*/
EXPLAIN (COSTS false) SELECT * FROM p2 WHERE id >= 50 AND id <= 51 AND p2.ctid = '(1,1)';
NOTICE:  SELECT uses system-defined column "p2.ctid" without the necessary companion column "p2.gp_segment_id"
HINT:  To uniquely identify a row within a distributed table, use the "gp_segment_id" column together with the "ctid" column.
LOG:  available indexes for IndexScan(p2_c1): p2_c1_id2_val
LOG:  pg_hint_plan:
used hint:
IndexScan(p2_c1 p2_c1_id2_val)
not used hint:
duplication hint:
error hint:
                                 QUERY PLAN                                  
-----------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Append
         ->  Seq Scan on p2 p2_1
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Index Scan using p2_c1_id2_val on p2_c1 p2_2
               Index Cond: ((id >= 50) AND (id <= 51))
               Filter: (ctid = '(1,1)'::tid)
         ->  Seq Scan on p2_c1_c1 p2_3
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
         ->  Seq Scan on p2_c1_c2 p2_4
               Filter: ((id >= 50) AND (id <= 51) AND (ctid = '(1,1)'::tid))
 Optimizer: Postgres query optimizer
(12 rows)

-- search from hint table
INSERT INTO hint_plan.hints (norm_query_string, application_name, hints) VALUES ('EXPLAIN (COSTS false) SELECT * FROM t1 WHERE t1.id = ?;', '', 'SeqScan(t1)');
LOG:  statement: INSERT INTO hint_plan.hints (norm_query_string, application_name, hints) VALUES ('EXPLAIN (COSTS false) SELECT * FROM t1 WHERE t1.id = ?;', '', 'SeqScan(t1)');
INSERT INTO hint_plan.hints (norm_query_string, application_name, hints) VALUES ('EXPLAIN (COSTS false) SELECT id FROM t1 WHERE t1.id = ?;', '', 'IndexScan(t1)');
LOG:  statement: INSERT INTO hint_plan.hints (norm_query_string, application_name, hints) VALUES ('EXPLAIN (COSTS false) SELECT id FROM t1 WHERE t1.id = ?;', '', 'IndexScan(t1)');
INSERT INTO hint_plan.hints (norm_query_string, application_name, hints) VALUES ('EXPLAIN SELECT * FROM t1 WHERE t1.id = ?;', '', 'BitmapScan(t1)');
LOG:  statement: INSERT INTO hint_plan.hints (norm_query_string, application_name, hints) VALUES ('EXPLAIN SELECT * FROM t1 WHERE t1.id = ?;', '', 'BitmapScan(t1)');
SELECT * FROM hint_plan.hints ORDER BY id;
LOG:  statement: SELECT * FROM hint_plan.hints ORDER BY id;
 id |                    norm_query_string                     | application_name |     hints      
----+----------------------------------------------------------+------------------+----------------
  1 | EXPLAIN (COSTS false) SELECT * FROM t1 WHERE t1.id = ?;  |                  | SeqScan(t1)
  2 | EXPLAIN (COSTS false) SELECT id FROM t1 WHERE t1.id = ?; |                  | IndexScan(t1)
  3 | EXPLAIN SELECT * FROM t1 WHERE t1.id = ?;                |                  | BitmapScan(t1)
(3 rows)

SET pg_hint_plan.enable_hint_table = on;
LOG:  statement: SET pg_hint_plan.enable_hint_table = on;
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE t1.id = 1;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1 WHERE t1.id = 1;
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Seq Scan on t1
         Filter: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

SET pg_hint_plan.enable_hint_table = off;
LOG:  statement: SET pg_hint_plan.enable_hint_table = off;
EXPLAIN (COSTS false) SELECT * FROM t1 WHERE t1.id = 1;
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1 WHERE t1.id = 1;
                QUERY PLAN                
------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Index Scan using t1_pkey on t1
         Index Cond: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

TRUNCATE hint_plan.hints;
LOG:  statement: TRUNCATE hint_plan.hints;
VACUUM ANALYZE hint_plan.hints;
LOG:  statement: VACUUM ANALYZE hint_plan.hints;
-- plpgsql test
EXPLAIN (COSTS false) SELECT id FROM t1 WHERE t1.id = 1;
LOG:  statement: EXPLAIN (COSTS false) SELECT id FROM t1 WHERE t1.id = 1;
                QUERY PLAN                 
-------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   ->  Index Only Scan using t1_pkey on t1
         Index Cond: (id = 1)
 Optimizer: Postgres query optimizer
(4 rows)

-- static function
-- not work, not sure why
CREATE FUNCTION testfunc() RETURNS RECORD AS $$
DECLARE
  ret record;
BEGIN
  SELECT /*+ SeqScan(t1) */ * INTO ret FROM t1 LIMIT 1;
  RETURN ret;
END;
$$ LANGUAGE plpgsql;
LOG:  statement: CREATE FUNCTION testfunc() RETURNS RECORD AS $$
DECLARE
  ret record;
BEGIN
  SELECT /*+ SeqScan(t1) */ * INTO ret FROM t1 LIMIT 1;
  RETURN ret;
END;
$$ LANGUAGE plpgsql;
explain SELECT testfunc();
LOG:  statement: explain SELECT testfunc();
                QUERY PLAN                 
-------------------------------------------
 Result  (cost=0.00..0.26 rows=1 width=32)
 Optimizer: Postgres query optimizer
(2 rows)

-- dynamic function
-- not work, not sure why
DROP FUNCTION testfunc();
LOG:  statement: DROP FUNCTION testfunc();
CREATE FUNCTION testfunc() RETURNS void AS $$
BEGIN
  EXECUTE format('/*+ SeqScan(t1) */ SELECT * FROM t1');
END;
$$ LANGUAGE plpgsql;
LOG:  statement: CREATE FUNCTION testfunc() RETURNS void AS $$
BEGIN
  EXECUTE format('/*+ SeqScan(t1) */ SELECT * FROM t1');
END;
$$ LANGUAGE plpgsql;
SELECT testfunc();
LOG:  statement: SELECT testfunc();
 testfunc 
----------
 
(1 row)

-- test partition table 
create table parttbl(v1 int, v2 int, v3 int) PARTITION BY RANGE (v1)
( PARTITION p1 START (0) INCLUSIVE, 
  PARTITION p2 START (100) INCLUSIVE,
  PARTITION p3 START (200) INCLUSIVE,
  DEFAULT PARTITION others);
LOG:  statement: create table parttbl(v1 int, v2 int, v3 int) PARTITION BY RANGE (v1)
( PARTITION p1 START (0) INCLUSIVE, 
  PARTITION p2 START (100) INCLUSIVE,
  PARTITION p3 START (200) INCLUSIVE,
  DEFAULT PARTITION others);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'v1' as the Cloudberry Database data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into parttbl values(generate_series(0, 300), generate_series(0, 300), generate_series(0, 300));
LOG:  statement: insert into parttbl values(generate_series(0, 300), generate_series(0, 300), generate_series(0, 300));
ANALYZE parttbl;
LOG:  statement: ANALYZE parttbl;
CREATE INDEX parttbl_idx_1 ON parttbl (v1);
LOG:  statement: CREATE INDEX parttbl_idx_1 ON parttbl (v1);
CREATE INDEX parttbl_idx_2 ON parttbl (v1, v2);
LOG:  statement: CREATE INDEX parttbl_idx_2 ON parttbl (v1, v2);
CREATE INDEX parttbl_1_prt_p1_idx_3 ON parttbl_1_prt_p1 (v1);
LOG:  statement: CREATE INDEX parttbl_1_prt_p1_idx_3 ON parttbl_1_prt_p1 (v1);
EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1);
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1);
                             QUERY PLAN                             
--------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = parttbl.v1)
         ->  Seq Scan on t1
         ->  Hash
               ->  Append
                     ->  Seq Scan on parttbl_1_prt_p1 parttbl_1
                     ->  Seq Scan on parttbl_1_prt_p2 parttbl_2
                     ->  Seq Scan on parttbl_1_prt_p3 parttbl_3
                     ->  Seq Scan on parttbl_1_prt_others parttbl_4
 Optimizer: Postgres query optimizer
(11 rows)

/*+HashJoin(t1 parttbl)*/
EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1);
LOG:  statement: /*+HashJoin(t1 parttbl)*/
EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1);
LOG:  pg_hint_plan:
used hint:
HashJoin(parttbl t1)
not used hint:
duplication hint:
error hint:
                             QUERY PLAN                             
--------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = parttbl.v1)
         ->  Seq Scan on t1
         ->  Hash
               ->  Append
                     ->  Seq Scan on parttbl_1_prt_p1 parttbl_1
                     ->  Seq Scan on parttbl_1_prt_p2 parttbl_2
                     ->  Seq Scan on parttbl_1_prt_p3 parttbl_3
                     ->  Seq Scan on parttbl_1_prt_others parttbl_4
 Optimizer: Postgres query optimizer
(11 rows)

/*+MergeJoin(t1 parttbl)*/
EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1);
LOG:  statement: /*+MergeJoin(t1 parttbl)*/
EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1);
LOG:  pg_hint_plan:
used hint:
MergeJoin(parttbl t1)
not used hint:
duplication hint:
error hint:
                             QUERY PLAN                             
--------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Join
         Merge Cond: (t1.id = parttbl.v1)
         ->  Index Scan using t1_pkey on t1
         ->  Sort
               Sort Key: parttbl.v1
               ->  Append
                     ->  Seq Scan on parttbl_1_prt_p1 parttbl_1
                     ->  Seq Scan on parttbl_1_prt_p2 parttbl_2
                     ->  Seq Scan on parttbl_1_prt_p3 parttbl_3
                     ->  Seq Scan on parttbl_1_prt_others parttbl_4
 Optimizer: Postgres query optimizer
(12 rows)

/*+NestLoop(t1 parttbl)*/
EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1);
LOG:  statement: /*+NestLoop(t1 parttbl)*/
EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1);
LOG:  pg_hint_plan:
used hint:
NestLoop(parttbl t1)
not used hint:
duplication hint:
error hint:
                          QUERY PLAN                          
--------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Append
               ->  Seq Scan on parttbl_1_prt_p1 parttbl_1
               ->  Seq Scan on parttbl_1_prt_p2 parttbl_2
               ->  Seq Scan on parttbl_1_prt_p3 parttbl_3
               ->  Seq Scan on parttbl_1_prt_others parttbl_4
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id = parttbl.v1)
 Optimizer: Postgres query optimizer
(10 rows)

/*+NestLoop(parttbl t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1);
LOG:  statement: /*+NestLoop(parttbl t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1);
LOG:  pg_hint_plan:
used hint:
NestLoop(parttbl t1)
not used hint:
duplication hint:
error hint:
                          QUERY PLAN                          
--------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Nested Loop
         ->  Append
               ->  Seq Scan on parttbl_1_prt_p1 parttbl_1
               ->  Seq Scan on parttbl_1_prt_p2 parttbl_2
               ->  Seq Scan on parttbl_1_prt_p3 parttbl_3
               ->  Seq Scan on parttbl_1_prt_others parttbl_4
         ->  Index Scan using t1_pkey on t1
               Index Cond: (id = parttbl.v1)
 Optimizer: Postgres query optimizer
(10 rows)

/*+IndexScan(parttbl)*/
EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1);
LOG:  statement: /*+IndexScan(parttbl)*/
EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1);
LOG:  pg_hint_plan:
used hint:
IndexScan(parttbl)
not used hint:
duplication hint:
error hint:
                                                QUERY PLAN                                                 
-----------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = parttbl.v1)
         ->  Seq Scan on t1
         ->  Hash
               ->  Append
                     ->  Index Scan using parttbl_1_prt_p1_idx_3 on parttbl_1_prt_p1 parttbl_1
                     ->  Index Scan using parttbl_1_prt_p2_v1_v2_idx on parttbl_1_prt_p2 parttbl_2
                     ->  Index Scan using parttbl_1_prt_p3_v1_v2_idx on parttbl_1_prt_p3 parttbl_3
                     ->  Index Scan using parttbl_1_prt_others_v1_v2_idx on parttbl_1_prt_others parttbl_4
 Optimizer: Postgres query optimizer
(11 rows)

/*+IndexScan(parttbl_1_prt_p1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1);
LOG:  statement: /*+IndexScan(parttbl_1_prt_p1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1);
LOG:  pg_hint_plan:
used hint:
IndexScan(parttbl_1_prt_p1)
not used hint:
duplication hint:
error hint:
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = parttbl.v1)
         ->  Seq Scan on t1
         ->  Hash
               ->  Append
                     ->  Index Scan using parttbl_1_prt_p1_idx_3 on parttbl_1_prt_p1 parttbl_1
                     ->  Seq Scan on parttbl_1_prt_p2 parttbl_2
                     ->  Seq Scan on parttbl_1_prt_p3 parttbl_3
                     ->  Seq Scan on parttbl_1_prt_others parttbl_4
 Optimizer: Postgres query optimizer
(11 rows)

/*+IndexScan(parttbl_1_prt_p1 parttbl_1_prt_p1_idx_3)*/
EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1);
LOG:  statement: /*+IndexScan(parttbl_1_prt_p1 parttbl_1_prt_p1_idx_3)*/
EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1);
LOG:  available indexes for IndexScan(parttbl_1_prt_p1): parttbl_1_prt_p1_idx_3
LOG:  pg_hint_plan:
used hint:
IndexScan(parttbl_1_prt_p1 parttbl_1_prt_p1_idx_3)
not used hint:
duplication hint:
error hint:
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = parttbl.v1)
         ->  Seq Scan on t1
         ->  Hash
               ->  Append
                     ->  Index Scan using parttbl_1_prt_p1_idx_3 on parttbl_1_prt_p1 parttbl_1
                     ->  Seq Scan on parttbl_1_prt_p2 parttbl_2
                     ->  Seq Scan on parttbl_1_prt_p3 parttbl_3
                     ->  Seq Scan on parttbl_1_prt_others parttbl_4
 Optimizer: Postgres query optimizer
(11 rows)

EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1) JOIN t2 ON (t1.id = t2.id);
LOG:  statement: EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1) JOIN t2 ON (t1.id = t2.id);
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = parttbl.v1)
         ->  Seq Scan on t1
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t2.id = parttbl.v1)
                     ->  Seq Scan on t2
                     ->  Hash
                           ->  Append
                                 ->  Seq Scan on parttbl_1_prt_p1 parttbl_1
                                 ->  Seq Scan on parttbl_1_prt_p2 parttbl_2
                                 ->  Seq Scan on parttbl_1_prt_p3 parttbl_3
                                 ->  Seq Scan on parttbl_1_prt_others parttbl_4
 Optimizer: Postgres query optimizer
(15 rows)

/*+Leading(t1 t2 parttbl)*/
EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1) JOIN t2 ON (t1.id = t2.id);
LOG:  statement: /*+Leading(t1 t2 parttbl)*/
EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1) JOIN t2 ON (t1.id = t2.id);
LOG:  pg_hint_plan:
used hint:
Leading(t1 t2 parttbl)
not used hint:
duplication hint:
error hint:
                             QUERY PLAN                             
--------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = parttbl.v1)
         ->  Hash Join
               Hash Cond: (t1.id = t2.id)
               ->  Seq Scan on t1
               ->  Hash
                     ->  Seq Scan on t2
         ->  Hash
               ->  Append
                     ->  Seq Scan on parttbl_1_prt_p1 parttbl_1
                     ->  Seq Scan on parttbl_1_prt_p2 parttbl_2
                     ->  Seq Scan on parttbl_1_prt_p3 parttbl_3
                     ->  Seq Scan on parttbl_1_prt_others parttbl_4
 Optimizer: Postgres query optimizer
(15 rows)

/*+Leading(parttbl t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1) JOIN t2 ON (t1.id = t2.id);
LOG:  statement: /*+Leading(parttbl t1 t2)*/
EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1) JOIN t2 ON (t1.id = t2.id);
LOG:  pg_hint_plan:
used hint:
Leading(parttbl t1 t2)
not used hint:
duplication hint:
error hint:
                                   QUERY PLAN                                   
--------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
         ->  Hash
               ->  Hash Join
                     Hash Cond: (t1.id = parttbl.v1)
                     ->  Seq Scan on t1
                     ->  Hash
                           ->  Append
                                 ->  Seq Scan on parttbl_1_prt_p1 parttbl_1
                                 ->  Seq Scan on parttbl_1_prt_p2 parttbl_2
                                 ->  Seq Scan on parttbl_1_prt_p3 parttbl_3
                                 ->  Seq Scan on parttbl_1_prt_others parttbl_4
 Optimizer: Postgres query optimizer
(15 rows)

/*+Leading(parttbl t1 t2)NestLoop(parttbl t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1) JOIN t2 ON (t1.id = t2.id);
LOG:  statement: /*+Leading(parttbl t1 t2)NestLoop(parttbl t1)*/
EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1) JOIN t2 ON (t1.id = t2.id);
LOG:  pg_hint_plan:
used hint:
NestLoop(parttbl t1)
Leading(parttbl t1 t2)
not used hint:
duplication hint:
error hint:
                                QUERY PLAN                                
--------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t2.id = t1.id)
         ->  Seq Scan on t2
         ->  Hash
               ->  Nested Loop
                     ->  Append
                           ->  Seq Scan on parttbl_1_prt_p1 parttbl_1
                           ->  Seq Scan on parttbl_1_prt_p2 parttbl_2
                           ->  Seq Scan on parttbl_1_prt_p3 parttbl_3
                           ->  Seq Scan on parttbl_1_prt_others parttbl_4
                     ->  Index Scan using t1_pkey on t1
                           Index Cond: (id = parttbl.v1)
 Optimizer: Postgres query optimizer
(14 rows)

/*+Leading(parttbl t1 t2)NestLoop(parttbl t1)IndexScan(parttbl_1_prt_p1 parttbl_1_prt_p1_idx_3)*/
EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1) JOIN t2 ON (t1.id = t2.id);
LOG:  statement: /*+Leading(parttbl t1 t2)NestLoop(parttbl t1)IndexScan(parttbl_1_prt_p1 parttbl_1_prt_p1_idx_3)*/
EXPLAIN (COSTS false) SELECT * FROM t1 JOIN parttbl ON (t1.id = parttbl.v1) JOIN t2 ON (t1.id = t2.id);
LOG:  available indexes for IndexScan(parttbl_1_prt_p1): parttbl_1_prt_p1_idx_3
LOG:  pg_hint_plan:
used hint:
IndexScan(parttbl_1_prt_p1 parttbl_1_prt_p1_idx_3)
NestLoop(parttbl t1)
Leading(parttbl t1 t2)
not used hint:
duplication hint:
error hint:
                                          QUERY PLAN                                           
-----------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Hash Join
         Hash Cond: (t1.id = t2.id)
         ->  Nested Loop
               ->  Append
                     ->  Index Scan using parttbl_1_prt_p1_idx_3 on parttbl_1_prt_p1 parttbl_1
                     ->  Seq Scan on parttbl_1_prt_p2 parttbl_2
                     ->  Seq Scan on parttbl_1_prt_p3 parttbl_3
                     ->  Seq Scan on parttbl_1_prt_others parttbl_4
               ->  Index Scan using t1_pkey on t1
                     Index Cond: (id = parttbl.v1)
         ->  Hash
               ->  Seq Scan on t2
 Optimizer: Postgres query optimizer
(14 rows)

-- all hint types together
/*+ SeqScan(t1) MergeJoin(t1 t2) Leading(t1 t2) Set(random_page_cost 2.0)*/
EXPLAIN (costs off) SELECT * FROM t1 JOIN t2 ON (t1.id = t2.id) JOIN t3 ON (t3.id = t2.id);
LOG:  statement: /*+ SeqScan(t1) MergeJoin(t1 t2) Leading(t1 t2) Set(random_page_cost 2.0)*/
EXPLAIN (costs off) SELECT * FROM t1 JOIN t2 ON (t1.id = t2.id) JOIN t3 ON (t3.id = t2.id);
LOG:  pg_hint_plan:
used hint:
SeqScan(t1)
MergeJoin(t1 t2)
Leading(t1 t2)
Set(random_page_cost 2.0)
not used hint:
duplication hint:
error hint:
                QUERY PLAN                 
-------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)
   ->  Merge Join
         Merge Cond: (t1.id = t3.id)
         ->  Merge Join
               Merge Cond: (t1.id = t2.id)
               ->  Sort
                     Sort Key: t1.id
                     ->  Seq Scan on t1
               ->  Sort
                     Sort Key: t2.id
                     ->  Seq Scan on t2
         ->  Sort
               Sort Key: t3.id
               ->  Seq Scan on t3
 Optimizer: Postgres query optimizer
(15 rows)

reset optimizer;
LOG:  statement: reset optimizer;
