-- GRANT's lock is the catalog tuple xmax.  GRANT doesn't acquire a heavyweight
-- lock on the object undergoing an ACL change.  In-place updates, namely
-- datfrozenxid, need special code to cope.

CREATE ROLE regress_temp_grantee;
CREATE

--start_ignore
DROP TABLE IF EXISTS frozen_witness;
DROP
--end_ignore

3: CREATE TEMPORARY TABLE frozen_witness (x xid) distributed by (x);
CREATE
-- observe datfrozenxid
3: INSERT INTO frozen_witness SELECT datfrozenxid FROM pg_database WHERE datname = current_catalog;
INSERT 1
1: BEGIN;
BEGIN
-- heap_update(pg_database)
1: GRANT TEMP ON DATABASE isolation2test TO regress_temp_grantee;
GRANT
-- inplace update
2&: VACUUM (FREEZE);  <waiting ...>
3: INSERT INTO frozen_witness SELECT datfrozenxid FROM pg_database WHERE datname = current_catalog;
INSERT 1
1: COMMIT;
COMMIT
2<:  <... completed>
VACUUM
-- Save the result in an environment variable.
-- We get the raw xid to be sure that the age in the next query will be executed on the coordinator.
3: @post_run 'TOKEN=`echo "${RAW_STR}" | awk \'NR==3\' | awk \'{print $1}\'` && echo ""' : SELECT min(x::varchar::int) FROM frozen_witness;

-- observe datfrozenxid
3: @pre_run 'echo "${RAW_STR}" | sed "s#@TOKEN#${TOKEN}#"': SELECT 'datfrozenxid retreated' FROM pg_database WHERE datname = current_catalog AND age(datfrozenxid) > age('@TOKEN'::xid);
 ?column? 
----------
(0 rows)

REVOKE ALL ON DATABASE isolation2test FROM regress_temp_grantee;
REVOKE
DROP ROLE regress_temp_grantee;
DROP

1q: ... <quitting>
2q: ... <quitting>
3q: ... <quitting>

-- Same test as the above, except the GRANT transaction commits before the
-- second transaction check the wait gxid, it should get the gxid from
-- pg_distributedlog instead of the procarray.
CREATE ROLE regress_temp_grantee;
CREATE

3: CREATE TEMPORARY TABLE frozen_witness (x xid) distributed by (x);
CREATE
-- observe datfrozenxid
3: INSERT INTO frozen_witness SELECT datfrozenxid FROM pg_database WHERE datname = current_catalog;
INSERT 1
1: BEGIN;
BEGIN
-- heap_update(pg_database)
1: GRANT TEMP ON DATABASE isolation2test TO regress_temp_grantee;
GRANT
-- suspend before get 'wait gxid'
2: SELECT gp_inject_fault('before_get_distributed_xid', 'suspend', dbid) FROM gp_segment_configuration WHERE role='p' AND content=0;
 gp_inject_fault 
-----------------
 Success:        
(1 row)
-- inplace update
2&: VACUUM (FREEZE);  <waiting ...>
3: SELECT gp_wait_until_triggered_fault('before_get_distributed_xid', 1, dbid) FROM gp_segment_configuration WHERE role='p' AND content=0;
 gp_wait_until_triggered_fault 
-------------------------------
 Success:                      
(1 row)
1: COMMIT;
COMMIT
3: INSERT INTO frozen_witness SELECT datfrozenxid FROM pg_database WHERE datname = current_catalog;
INSERT 1
3: SELECT gp_inject_fault('before_get_distributed_xid', 'reset', dbid) FROM gp_segment_configuration WHERE role='p' AND content=0;
 gp_inject_fault 
-----------------
 Success:        
(1 row)

2<:  <... completed>
VACUUM
-- Save the result in an environment variable.
-- We get the raw xid to be sure that the age in the next query will be executed on the coordinator.
3: @post_run 'TOKEN=`echo "${RAW_STR}" | awk \'NR==3\' | awk \'{print $1}\'` && echo ""' : SELECT min(x::varchar::int) FROM frozen_witness;

-- observe datfrozenxid
3: @pre_run 'echo "${RAW_STR}" | sed "s#@TOKEN#${TOKEN}#"': SELECT 'datfrozenxid retreated' FROM pg_database WHERE datname = current_catalog AND age(datfrozenxid) > age('@TOKEN'::xid);
 ?column? 
----------
(0 rows)

REVOKE ALL ON DATABASE isolation2test FROM regress_temp_grantee;
REVOKE
DROP ROLE regress_temp_grantee;
DROP

1q: ... <quitting>
2q: ... <quitting>
3q: ... <quitting>
