-- start_ignore
drop table if exists t1;
drop table if exists t2;
SET optimizer_trace_fallback = on;
-- end_ignore
create table t1(v1 int, v2 int, v3 int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'v1' as the Apache Cloudberry data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into t1 values(generate_series(1, 10), generate_series(11, 20), generate_series(21, 30));
analyze t1;
create table t2(v1 int, v2 int, v3 int);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'v1' as the Apache Cloudberry data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
insert into t2 values(generate_series(0, 100), generate_series(100, 200), generate_series(200, 300));
-- should pruned both seq scan and shared scan
explain verbose with c1 as (select v1, v2, v3 from t1) select c11.v1 from c1 as c11 left join c1 as c22 on c11.v1=c22.v1 where c11.v1 < 5;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..1293.00 rows=5 width=4)
   Output: share0_ref3.v1
   ->  Sequence  (cost=0.00..1293.00 rows=2 width=4)
         Output: share0_ref3.v1
         ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=2 width=1)
               Output: share0_ref1.v1
               ->  Seq Scan on cte_prune.t1  (cost=0.00..431.00 rows=2 width=4)
                     Output: t1.v1
                     Filter: (t1.v1 < 5)
         ->  Hash Left Join  (cost=0.00..862.00 rows=2 width=4)
               Output: share0_ref3.v1
               Hash Cond: (share0_ref3.v1 = share0_ref2.v1)
               ->  Result  (cost=0.00..431.00 rows=2 width=4)
                     Output: share0_ref3.v1
                     Filter: (share0_ref3.v1 < 5)
                     ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=2 width=4)
                           Output: share0_ref3.v1
               ->  Hash  (cost=431.00..431.00 rows=2 width=4)
                     Output: share0_ref2.v1
                     ->  Result  (cost=0.00..431.00 rows=2 width=4)
                           Output: share0_ref2.v1
                           Filter: (share0_ref2.v1 < 5)
                           ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=2 width=4)
                                 Output: share0_ref2.v1
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(26 rows)

with c1 as (select v1, v2, v3 from t1) select c11.v1 from c1 as c11 left join c1 as c22 on c11.v1=c22.v1 where c11.v1 < 5;
 v1 
----
  1
  2
  3
  4
(4 rows)

explain verbose with c1 as (select v1, v2, v3 from t1) select c11.v2 from c1 as c11 left join c1 as c22 on c11.v1=c22.v1 where c11.v1 < 5;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..1293.00 rows=5 width=4)
   Output: share0_ref3.v2
   ->  Sequence  (cost=0.00..1293.00 rows=2 width=4)
         Output: share0_ref3.v2
         ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=2 width=1)
               Output: share0_ref1.v1, share0_ref1.v2
               ->  Seq Scan on cte_prune.t1  (cost=0.00..431.00 rows=2 width=8)
                     Output: t1.v1, t1.v2
                     Filter: (t1.v1 < 5)
         ->  Hash Left Join  (cost=0.00..862.00 rows=2 width=4)
               Output: share0_ref3.v2
               Hash Cond: (share0_ref3.v1 = share0_ref2.v1)
               ->  Result  (cost=0.00..431.00 rows=2 width=8)
                     Output: share0_ref3.v1, share0_ref3.v2
                     Filter: (share0_ref3.v1 < 5)
                     ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=2 width=8)
                           Output: share0_ref3.v1, share0_ref3.v2
               ->  Hash  (cost=431.00..431.00 rows=2 width=4)
                     Output: share0_ref2.v1
                     ->  Result  (cost=0.00..431.00 rows=2 width=4)
                           Output: share0_ref2.v1
                           Filter: (share0_ref2.v1 < 5)
                           ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=2 width=4)
                                 Output: share0_ref2.v1, share0_ref2.v2
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(26 rows)

with c1 as (select v1, v2, v3 from t1) select c11.v2 from c1 as c11 left join c1 as c22 on c11.v1=c22.v1 where c11.v1 < 5;
 v2 
----
 12
 13
 14
 11
(4 rows)

explain verbose with c1 as (select v1, v2, v3 from t1) select c11.v3 from c1 as c11 left join c1 as c22 on c11.v1=c22.v1 where c11.v1 < 5;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..1293.00 rows=5 width=4)
   Output: share0_ref3.v3
   ->  Sequence  (cost=0.00..1293.00 rows=2 width=4)
         Output: share0_ref3.v3
         ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=2 width=1)
               Output: share0_ref1.v1, share0_ref1.v3
               ->  Seq Scan on cte_prune.t1  (cost=0.00..431.00 rows=2 width=8)
                     Output: t1.v1, t1.v3
                     Filter: (t1.v1 < 5)
         ->  Hash Left Join  (cost=0.00..862.00 rows=2 width=4)
               Output: share0_ref3.v3
               Hash Cond: (share0_ref3.v1 = share0_ref2.v1)
               ->  Result  (cost=0.00..431.00 rows=2 width=8)
                     Output: share0_ref3.v1, share0_ref3.v3
                     Filter: (share0_ref3.v1 < 5)
                     ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=2 width=8)
                           Output: share0_ref3.v1, share0_ref3.v3
               ->  Hash  (cost=431.00..431.00 rows=2 width=4)
                     Output: share0_ref2.v1
                     ->  Result  (cost=0.00..431.00 rows=2 width=4)
                           Output: share0_ref2.v1
                           Filter: (share0_ref2.v1 < 5)
                           ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=2 width=4)
                                 Output: share0_ref2.v1, share0_ref2.v3
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(26 rows)

with c1 as (select v1, v2, v3 from t1) select c11.v3 from c1 as c11 left join c1 as c22 on c11.v1=c22.v1 where c11.v1 < 5;
 v3 
----
 22
 23
 24
 21
(4 rows)

-- * also should be pruned
explain verbose with c1 as (select * from t1) select c11.v1 from c1 as c11 left join c1 as c22 on c11.v1=c22.v1 where c11.v1 < 5;
                                             QUERY PLAN                                             
----------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..1293.00 rows=5 width=4)
   Output: share0_ref3.v1
   ->  Sequence  (cost=0.00..1293.00 rows=2 width=4)
         Output: share0_ref3.v1
         ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=2 width=1)
               Output: share0_ref1.v1
               ->  Seq Scan on cte_prune.t1  (cost=0.00..431.00 rows=2 width=4)
                     Output: t1.v1
                     Filter: (t1.v1 < 5)
         ->  Hash Left Join  (cost=0.00..862.00 rows=2 width=4)
               Output: share0_ref3.v1
               Hash Cond: (share0_ref3.v1 = share0_ref2.v1)
               ->  Result  (cost=0.00..431.00 rows=2 width=4)
                     Output: share0_ref3.v1
                     Filter: (share0_ref3.v1 < 5)
                     ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=2 width=4)
                           Output: share0_ref3.v1
               ->  Hash  (cost=431.00..431.00 rows=2 width=4)
                     Output: share0_ref2.v1
                     ->  Result  (cost=0.00..431.00 rows=2 width=4)
                           Output: share0_ref2.v1
                           Filter: (share0_ref2.v1 < 5)
                           ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=2 width=4)
                                 Output: share0_ref2.v1
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(26 rows)

with c1 as (select * from t1) select c11.v1 from c1 as c11 left join c1 as c22 on c11.v1=c22.v1 where c11.v1 < 5;
 v1 
----
  1
  2
  3
  4
(4 rows)

-- no push filter
explain verbose with c1 as (select v1, v2, v3 from t1) select c11.v3 from c1 as c11 left join c1 as c22 on c11.v1=c22.v2;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..1293.00 rows=11 width=4)
   Output: share0_ref3.v3
   ->  Sequence  (cost=0.00..1293.00 rows=4 width=4)
         Output: share0_ref3.v3
         ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=1)
               Output: share0_ref1.v1, share0_ref1.v2, share0_ref1.v3
               ->  Seq Scan on cte_prune.t1  (cost=0.00..431.00 rows=4 width=12)
                     Output: t1.v1, t1.v2, t1.v3
         ->  Hash Left Join  (cost=0.00..862.00 rows=4 width=4)
               Output: share0_ref3.v3
               Hash Cond: (share0_ref3.v1 = share0_ref2.v2)
               ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=8)
                     Output: share0_ref3.v1, share0_ref3.v2, share0_ref3.v3
               ->  Hash  (cost=431.00..431.00 rows=4 width=4)
                     Output: share0_ref2.v2
                     ->  Redistribute Motion 3:3  (slice2; segments: 3)  (cost=0.00..431.00 rows=4 width=4)
                           Output: share0_ref2.v2
                           Hash Key: share0_ref2.v2
                           ->  Result  (cost=0.00..431.00 rows=4 width=4)
                                 Output: share0_ref2.v2
                                 ->  Shared Scan (share slice:id 2:0)  (cost=0.00..431.00 rows=4 width=4)
                                       Output: share0_ref2.v1, share0_ref2.v2, share0_ref2.v3
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(24 rows)

with c1 as (select v1, v2, v3 from t1) select c11.v3 from c1 as c11 left join c1 as c22 on c11.v1=c22.v2;
 v3 
----
 26
 25
 30
 29
 21
 27
 23
 28
 24
 22
(10 rows)

explain verbose with c1 as (select v1, v2, v3 from t1) select c11.v2 from c1 as c11 left join c1 as c22 on c11.v1=c22.v2;
                                                 QUERY PLAN                                                 
------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..1293.00 rows=11 width=4)
   Output: share0_ref3.v2
   ->  Sequence  (cost=0.00..1293.00 rows=4 width=4)
         Output: share0_ref3.v2
         ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=1)
               Output: share0_ref1.v1, share0_ref1.v2
               ->  Seq Scan on cte_prune.t1  (cost=0.00..431.00 rows=4 width=8)
                     Output: t1.v1, t1.v2
         ->  Hash Left Join  (cost=0.00..862.00 rows=4 width=4)
               Output: share0_ref3.v2
               Hash Cond: (share0_ref3.v1 = share0_ref2.v2)
               ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=8)
                     Output: share0_ref3.v1, share0_ref3.v2
               ->  Hash  (cost=431.00..431.00 rows=4 width=4)
                     Output: share0_ref2.v2
                     ->  Redistribute Motion 3:3  (slice2; segments: 3)  (cost=0.00..431.00 rows=4 width=4)
                           Output: share0_ref2.v2
                           Hash Key: share0_ref2.v2
                           ->  Result  (cost=0.00..431.00 rows=4 width=4)
                                 Output: share0_ref2.v2
                                 ->  Shared Scan (share slice:id 2:0)  (cost=0.00..431.00 rows=4 width=4)
                                       Output: share0_ref2.v1, share0_ref2.v2
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(24 rows)

with c1 as (select v1, v2, v3 from t1) select c11.v2 from c1 as c11 left join c1 as c22 on c11.v1=c22.v2;
 v2 
----
 17
 13
 18
 14
 12
 16
 15
 20
 19
 11
(10 rows)

-- distribution col can be pruned which is better than do redistribute in CTE consumer
explain verbose with c1 as (select v1, v2, v3 from t1) select c11.v2 from c1 as c11 left join c1 as c22 on c11.v2=c22.v2;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..1293.00 rows=10 width=4)
   Output: share0_ref3.v2
   ->  Sequence  (cost=0.00..1293.00 rows=4 width=4)
         Output: share0_ref3.v2
         ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=1)
               Output: share0_ref1.v2
               ->  Redistribute Motion 3:3  (slice2; segments: 3)  (cost=0.00..431.00 rows=4 width=4)
                     Output: t1.v2
                     Hash Key: t1.v2
                     ->  Seq Scan on cte_prune.t1  (cost=0.00..431.00 rows=4 width=4)
                           Output: t1.v2
         ->  Hash Left Join  (cost=0.00..862.00 rows=4 width=4)
               Output: share0_ref3.v2
               Hash Cond: (share0_ref3.v2 = share0_ref2.v2)
               ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=4)
                     Output: share0_ref3.v2
               ->  Hash  (cost=431.00..431.00 rows=4 width=4)
                     Output: share0_ref2.v2
                     ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=4)
                           Output: share0_ref2.v2
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(22 rows)

with c1 as (select v1, v2, v3 from t1) select c11.v2 from c1 as c11 left join c1 as c22 on c11.v2=c22.v2;
 v2 
----
 18
 16
 19
 13
 14
 17
 11
 12
 15
 20
(10 rows)

explain verbose with c1 as (select v1, v2, v3 from t1) select c11.v3 from c1 as c11 left join c1 as c22 on c11.v3=c22.v3;
                                              QUERY PLAN                                              
------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..1293.00 rows=10 width=4)
   Output: share0_ref3.v3
   ->  Sequence  (cost=0.00..1293.00 rows=4 width=4)
         Output: share0_ref3.v3
         ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=1)
               Output: share0_ref1.v3
               ->  Redistribute Motion 3:3  (slice2; segments: 3)  (cost=0.00..431.00 rows=4 width=4)
                     Output: t1.v3
                     Hash Key: t1.v3
                     ->  Seq Scan on cte_prune.t1  (cost=0.00..431.00 rows=4 width=4)
                           Output: t1.v3
         ->  Hash Left Join  (cost=0.00..862.00 rows=4 width=4)
               Output: share0_ref3.v3
               Hash Cond: (share0_ref3.v3 = share0_ref2.v3)
               ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=4)
                     Output: share0_ref3.v3
               ->  Hash  (cost=431.00..431.00 rows=4 width=4)
                     Output: share0_ref2.v3
                     ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=4)
                           Output: share0_ref2.v3
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(22 rows)

with c1 as (select v1, v2, v3 from t1) select c11.v3 from c1 as c11 left join c1 as c22 on c11.v3=c22.v3;
 v3 
----
 22
 24
 27
 29
 28
 21
 25
 23
 26
 30
(10 rows)

-- groupby/order by/window function/grouping set should be contains in CTE output
-- group by 
explain verbose with c1 as (select v1, v2, v3 from t1) select sum(c11.v1) from c1 as c11 left join c1 as c22 on c11.v1=c22.v1 group by c11.v1;
                                                   QUERY PLAN                                                   
----------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..1293.00 rows=10 width=8)
   Output: (sum(share0_ref3.v1))
   ->  Result  (cost=0.00..1293.00 rows=4 width=8)
         Output: (sum(share0_ref3.v1))
         ->  Sequence  (cost=0.00..1293.00 rows=4 width=8)
               Output: (sum(share0_ref3.v1)), share0_ref3.v1
               ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=1)
                     Output: share0_ref1.v1
                     ->  Seq Scan on cte_prune.t1  (cost=0.00..431.00 rows=4 width=4)
                           Output: t1.v1
               ->  GroupAggregate  (cost=0.00..862.00 rows=4 width=8)
                     Output: sum(share0_ref3.v1), share0_ref3.v1
                     Group Key: share0_ref3.v1
                     ->  Sort  (cost=0.00..862.00 rows=4 width=4)
                           Output: share0_ref3.v1
                           Sort Key: share0_ref3.v1
                           ->  Hash Left Join  (cost=0.00..862.00 rows=4 width=4)
                                 Output: share0_ref3.v1
                                 Hash Cond: (share0_ref3.v1 = share0_ref2.v1)
                                 ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=4)
                                       Output: share0_ref3.v1
                                 ->  Hash  (cost=431.00..431.00 rows=4 width=4)
                                       Output: share0_ref2.v1
                                       ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=4)
                                             Output: share0_ref2.v1
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(27 rows)

with c1 as (select v1, v2, v3 from t1) select sum(c11.v1) from c1 as c11 left join c1 as c22 on c11.v1=c22.v1 group by c11.v1;
 sum 
-----
   4
   2
   8
   7
   3
  10
   9
   6
   5
   1
(10 rows)

explain verbose with c1 as (select v1, v2, v3 from t1) select sum(c11.v1) from c1 as c11 left join c1 as c22 on c11.v1=c22.v1 group by c11.v2;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..1293.00 rows=10 width=8)
   Output: (sum(share0_ref3.v1))
   ->  Result  (cost=0.00..1293.00 rows=4 width=8)
         Output: (sum(share0_ref3.v1))
         ->  Sequence  (cost=0.00..1293.00 rows=4 width=8)
               Output: (sum(share0_ref3.v1)), share0_ref3.v2
               ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=1)
                     Output: share0_ref1.v1, share0_ref1.v2
                     ->  Seq Scan on cte_prune.t1  (cost=0.00..431.00 rows=4 width=8)
                           Output: t1.v1, t1.v2
               ->  GroupAggregate  (cost=0.00..862.00 rows=4 width=8)
                     Output: sum(share0_ref3.v1), share0_ref3.v2
                     Group Key: share0_ref3.v2
                     ->  Sort  (cost=0.00..862.00 rows=4 width=8)
                           Output: share0_ref3.v1, share0_ref3.v2
                           Sort Key: share0_ref3.v2
                           ->  Redistribute Motion 3:3  (slice2; segments: 3)  (cost=0.00..862.00 rows=4 width=8)
                                 Output: share0_ref3.v1, share0_ref3.v2
                                 Hash Key: share0_ref3.v2
                                 ->  Hash Left Join  (cost=0.00..862.00 rows=4 width=8)
                                       Output: share0_ref3.v1, share0_ref3.v2
                                       Hash Cond: (share0_ref3.v1 = share0_ref2.v1)
                                       ->  Shared Scan (share slice:id 2:0)  (cost=0.00..431.00 rows=4 width=8)
                                             Output: share0_ref3.v1, share0_ref3.v2
                                       ->  Hash  (cost=431.00..431.00 rows=4 width=4)
                                             Output: share0_ref2.v1, share0_ref2.v2
                                             ->  Shared Scan (share slice:id 2:0)  (cost=0.00..431.00 rows=4 width=4)
                                                   Output: share0_ref2.v1, share0_ref2.v2
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(30 rows)

with c1 as (select v1, v2, v3 from t1) select sum(c11.v1) from c1 as c11 left join c1 as c22 on c11.v1=c22.v1 group by c11.v2;
 sum 
-----
   6
   9
   8
  10
   2
   5
   1
   3
   4
   7
(10 rows)

explain verbose with c1 as (select v1, v2, v3 from t1) select sum(c11.v3) from c1 as c11 left join c1 as c22 on c11.v1=c22.v1 group by c11.v2;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..1293.00 rows=10 width=8)
   Output: (sum(share0_ref3.v3))
   ->  Result  (cost=0.00..1293.00 rows=4 width=8)
         Output: (sum(share0_ref3.v3))
         ->  Sequence  (cost=0.00..1293.00 rows=4 width=8)
               Output: (sum(share0_ref3.v3)), share0_ref3.v2
               ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=1)
                     Output: share0_ref1.v1, share0_ref1.v2, share0_ref1.v3
                     ->  Seq Scan on cte_prune.t1  (cost=0.00..431.00 rows=4 width=12)
                           Output: t1.v1, t1.v2, t1.v3
               ->  GroupAggregate  (cost=0.00..862.00 rows=4 width=8)
                     Output: sum(share0_ref3.v3), share0_ref3.v2
                     Group Key: share0_ref3.v2
                     ->  Sort  (cost=0.00..862.00 rows=4 width=8)
                           Output: share0_ref3.v2, share0_ref3.v3
                           Sort Key: share0_ref3.v2
                           ->  Redistribute Motion 3:3  (slice2; segments: 3)  (cost=0.00..862.00 rows=4 width=8)
                                 Output: share0_ref3.v2, share0_ref3.v3
                                 Hash Key: share0_ref3.v2
                                 ->  Hash Left Join  (cost=0.00..862.00 rows=4 width=8)
                                       Output: share0_ref3.v2, share0_ref3.v3
                                       Hash Cond: (share0_ref3.v1 = share0_ref2.v1)
                                       ->  Shared Scan (share slice:id 2:0)  (cost=0.00..431.00 rows=4 width=12)
                                             Output: share0_ref3.v1, share0_ref3.v2, share0_ref3.v3
                                       ->  Hash  (cost=431.00..431.00 rows=4 width=4)
                                             Output: share0_ref2.v1, share0_ref2.v2, share0_ref2.v3
                                             ->  Shared Scan (share slice:id 2:0)  (cost=0.00..431.00 rows=4 width=4)
                                                   Output: share0_ref2.v1, share0_ref2.v2, share0_ref2.v3
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(30 rows)

with c1 as (select v1, v2, v3 from t1) select sum(c11.v3) from c1 as c11 left join c1 as c22 on c11.v1=c22.v1 group by c11.v2;
 sum 
-----
  26
  29
  28
  30
  22
  25
  21
  23
  24
  27
(10 rows)

-- order by 
explain verbose with c1 as (select v1, v2, v3 from t1) select c11.v1 from c1 as c11 left join c1 as c22 on c11.v1=c22.v1 order by c22.v1;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Result  (cost=0.00..1293.00 rows=10 width=4)
   Output: share0_ref3.v1
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..1293.00 rows=10 width=4)
         Output: share0_ref3.v1, share0_ref2.v1
         Merge Key: share0_ref2.v1
         ->  Sort  (cost=0.00..1293.00 rows=4 width=8)
               Output: share0_ref3.v1, share0_ref2.v1
               Sort Key: share0_ref2.v1
               ->  Sequence  (cost=0.00..1293.00 rows=4 width=8)
                     Output: share0_ref3.v1, share0_ref2.v1
                     ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=1)
                           Output: share0_ref1.v1
                           ->  Seq Scan on cte_prune.t1  (cost=0.00..431.00 rows=4 width=4)
                                 Output: t1.v1
                     ->  Hash Left Join  (cost=0.00..862.00 rows=4 width=8)
                           Output: share0_ref3.v1, share0_ref2.v1
                           Hash Cond: (share0_ref3.v1 = share0_ref2.v1)
                           ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=4)
                                 Output: share0_ref3.v1
                           ->  Hash  (cost=431.00..431.00 rows=4 width=4)
                                 Output: share0_ref2.v1
                                 ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=4)
                                       Output: share0_ref2.v1
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(25 rows)

with c1 as (select v1, v2, v3 from t1) select c11.v1 from c1 as c11 left join c1 as c22 on c11.v1=c22.v1 order by c22.v1;
 v1 
----
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
(10 rows)

explain verbose with c1 as (select v1, v2, v3 from t1) select c11.v1 from c1 as c11 left join c1 as c22 on c11.v1=c22.v1 order by c22.v3;
                                                QUERY PLAN                                                
----------------------------------------------------------------------------------------------------------
 Result  (cost=0.00..1293.00 rows=10 width=4)
   Output: share0_ref3.v1
   ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..1293.00 rows=10 width=4)
         Output: share0_ref3.v1, share0_ref2.v3
         Merge Key: share0_ref2.v3
         ->  Sort  (cost=0.00..1293.00 rows=4 width=8)
               Output: share0_ref3.v1, share0_ref2.v3
               Sort Key: share0_ref2.v3
               ->  Sequence  (cost=0.00..1293.00 rows=4 width=8)
                     Output: share0_ref3.v1, share0_ref2.v3
                     ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=1)
                           Output: share0_ref1.v1, share0_ref1.v3
                           ->  Seq Scan on cte_prune.t1  (cost=0.00..431.00 rows=4 width=8)
                                 Output: t1.v1, t1.v3
                     ->  Hash Left Join  (cost=0.00..862.00 rows=4 width=8)
                           Output: share0_ref3.v1, share0_ref2.v3
                           Hash Cond: (share0_ref3.v1 = share0_ref2.v1)
                           ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=4)
                                 Output: share0_ref3.v1, share0_ref3.v3
                           ->  Hash  (cost=431.00..431.00 rows=4 width=8)
                                 Output: share0_ref2.v1, share0_ref2.v3
                                 ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=8)
                                       Output: share0_ref2.v1, share0_ref2.v3
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(25 rows)

with c1 as (select v1, v2, v3 from t1) select c11.v1 from c1 as c11 left join c1 as c22 on c11.v1=c22.v1 order by c22.v3;
 v1 
----
  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
(10 rows)

-- window function
explain verbose with c1 as (select v1, v2, v3 from t1) select sum(c11.v1) OVER (ORDER BY c11.v2) from c1 as c11 left join c1 as c22 on c11.v1=c22.v1;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..1293.00 rows=10 width=8)
   Output: (sum(share0_ref3.v1) OVER (?))
   ->  Sequence  (cost=0.00..1293.00 rows=4 width=8)
         Output: (sum(share0_ref3.v1) OVER (?))
         ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=1)
               Output: share0_ref1.v1, share0_ref1.v2
               ->  Seq Scan on cte_prune.t1  (cost=0.00..431.00 rows=4 width=8)
                     Output: t1.v1, t1.v2
         ->  Redistribute Motion 1:3  (slice2)  (cost=0.00..862.00 rows=4 width=8)
               Output: (sum(share0_ref3.v1) OVER (?))
               ->  WindowAgg  (cost=0.00..862.00 rows=10 width=8)
                     Output: sum(share0_ref3.v1) OVER (?)
                     Order By: share0_ref3.v2
                     ->  Gather Motion 3:1  (slice3; segments: 3)  (cost=0.00..862.00 rows=10 width=8)
                           Output: share0_ref3.v1, share0_ref3.v2
                           Merge Key: share0_ref3.v2
                           ->  Sort  (cost=0.00..862.00 rows=4 width=8)
                                 Output: share0_ref3.v1, share0_ref3.v2
                                 Sort Key: share0_ref3.v2
                                 ->  Hash Left Join  (cost=0.00..862.00 rows=4 width=8)
                                       Output: share0_ref3.v1, share0_ref3.v2
                                       Hash Cond: (share0_ref3.v1 = share0_ref2.v1)
                                       ->  Shared Scan (share slice:id 3:0)  (cost=0.00..431.00 rows=4 width=8)
                                             Output: share0_ref3.v1, share0_ref3.v2
                                       ->  Hash  (cost=431.00..431.00 rows=4 width=4)
                                             Output: share0_ref2.v1, share0_ref2.v2
                                             ->  Shared Scan (share slice:id 3:0)  (cost=0.00..431.00 rows=4 width=4)
                                                   Output: share0_ref2.v1, share0_ref2.v2
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(30 rows)

with c1 as (select v1, v2, v3 from t1) select sum(c11.v1) OVER (ORDER BY c11.v2) from c1 as c11 left join c1 as c22 on c11.v1=c22.v1;
 sum 
-----
   1
   3
   6
  10
  15
  21
  28
  36
  45
  55
(10 rows)

explain verbose with c1 as (select v1, v2, v3 from t1) select sum(c11.v2) OVER (ORDER BY c11.v3) from c1 as c11 left join c1 as c22 on c11.v1=c22.v1;
                                                      QUERY PLAN                                                      
----------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..1293.00 rows=10 width=8)
   Output: (sum(share0_ref3.v2) OVER (?))
   ->  Sequence  (cost=0.00..1293.00 rows=4 width=8)
         Output: (sum(share0_ref3.v2) OVER (?))
         ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=1)
               Output: share0_ref1.v1, share0_ref1.v2, share0_ref1.v3
               ->  Seq Scan on cte_prune.t1  (cost=0.00..431.00 rows=4 width=12)
                     Output: t1.v1, t1.v2, t1.v3
         ->  Redistribute Motion 1:3  (slice2)  (cost=0.00..862.00 rows=4 width=8)
               Output: (sum(share0_ref3.v2) OVER (?))
               ->  WindowAgg  (cost=0.00..862.00 rows=10 width=8)
                     Output: sum(share0_ref3.v2) OVER (?)
                     Order By: share0_ref3.v3
                     ->  Gather Motion 3:1  (slice3; segments: 3)  (cost=0.00..862.00 rows=10 width=8)
                           Output: share0_ref3.v2, share0_ref3.v3
                           Merge Key: share0_ref3.v3
                           ->  Sort  (cost=0.00..862.00 rows=4 width=8)
                                 Output: share0_ref3.v2, share0_ref3.v3
                                 Sort Key: share0_ref3.v3
                                 ->  Hash Left Join  (cost=0.00..862.00 rows=4 width=8)
                                       Output: share0_ref3.v2, share0_ref3.v3
                                       Hash Cond: (share0_ref3.v1 = share0_ref2.v1)
                                       ->  Shared Scan (share slice:id 3:0)  (cost=0.00..431.00 rows=4 width=12)
                                             Output: share0_ref3.v1, share0_ref3.v2, share0_ref3.v3
                                       ->  Hash  (cost=431.00..431.00 rows=4 width=4)
                                             Output: share0_ref2.v1, share0_ref2.v2, share0_ref2.v3
                                             ->  Shared Scan (share slice:id 3:0)  (cost=0.00..431.00 rows=4 width=4)
                                                   Output: share0_ref2.v1, share0_ref2.v2, share0_ref2.v3
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(30 rows)

with c1 as (select v1, v2, v3 from t1) select sum(c11.v2) OVER (ORDER BY c11.v3) from c1 as c11 left join c1 as c22 on c11.v1=c22.v1;
 sum 
-----
  11
  23
  36
  50
  65
  81
  98
 116
 135
 155
(10 rows)

-- grouping set 
explain verbose with c1 as (select v1, v2, v3 from t1) select sum(c11.v2) from c1 as c11 left join c1 as c22 on c11.v1=c22.v1 group by ROLLUP(c11.v1,c11.v2);
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..2586.00 rows=21 width=8)
   Output: (sum(share1_ref2.v2))
   ->  Sequence  (cost=0.00..2586.00 rows=7 width=8)
         Output: (sum(share1_ref2.v2))
         ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=1)
               Output: share0_ref1.v1, share0_ref1.v2
               ->  Seq Scan on cte_prune.t1  (cost=0.00..431.00 rows=4 width=8)
                     Output: t1.v1, t1.v2
         ->  Sequence  (cost=0.00..2155.00 rows=7 width=8)
               Output: (sum(share1_ref2.v2))
               ->  Shared Scan (share slice:id 1:1)  (cost=0.00..862.00 rows=4 width=1)
                     Output: share1_ref1.v1, share1_ref1.v2
                     ->  Hash Left Join  (cost=0.00..862.00 rows=4 width=8)
                           Output: share0_ref3.v1, share0_ref3.v2
                           Hash Cond: (share0_ref3.v1 = share0_ref2.v1)
                           ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=8)
                                 Output: share0_ref3.v1, share0_ref3.v2
                           ->  Hash  (cost=431.00..431.00 rows=4 width=4)
                                 Output: share0_ref2.v1, share0_ref2.v2
                                 ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=4)
                                       Output: share0_ref2.v1, share0_ref2.v2
               ->  Append  (cost=0.00..1293.00 rows=7 width=8)
                     ->  GroupAggregate  (cost=0.00..431.00 rows=4 width=8)
                           Output: sum(share1_ref2.v2)
                           Group Key: share1_ref2.v1, share1_ref2.v2
                           ->  Sort  (cost=0.00..431.00 rows=4 width=8)
                                 Output: share1_ref2.v1, share1_ref2.v2
                                 Sort Key: share1_ref2.v1, share1_ref2.v2
                                 ->  Shared Scan (share slice:id 1:1)  (cost=0.00..431.00 rows=4 width=8)
                                       Output: share1_ref2.v1, share1_ref2.v2
                     ->  GroupAggregate  (cost=0.00..431.00 rows=4 width=8)
                           Output: sum(share1_ref3.v2)
                           Group Key: share1_ref3.v1
                           ->  Sort  (cost=0.00..431.00 rows=4 width=8)
                                 Output: share1_ref3.v1, share1_ref3.v2
                                 Sort Key: share1_ref3.v1
                                 ->  Shared Scan (share slice:id 1:1)  (cost=0.00..431.00 rows=4 width=8)
                                       Output: share1_ref3.v1, share1_ref3.v2
                     ->  Result  (cost=0.00..431.00 rows=1 width=8)
                           Output: (sum(share1_ref4.v2))
                           ->  Redistribute Motion 1:3  (slice2)  (cost=0.00..431.00 rows=1 width=8)
                                 Output: (sum(share1_ref4.v2))
                                 ->  Finalize Aggregate  (cost=0.00..431.00 rows=1 width=8)
                                       Output: sum(share1_ref4.v2)
                                       ->  Gather Motion 3:1  (slice3; segments: 3)  (cost=0.00..431.00 rows=1 width=8)
                                             Output: (PARTIAL sum(share1_ref4.v2))
                                             ->  Partial Aggregate  (cost=0.00..431.00 rows=1 width=8)
                                                   Output: PARTIAL sum(share1_ref4.v2)
                                                   ->  Shared Scan (share slice:id 3:1)  (cost=0.00..431.00 rows=4 width=4)
                                                         Output: share1_ref4.v1, share1_ref4.v2
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(52 rows)

with c1 as (select v1, v2, v3 from t1) select sum(c11.v2) from c1 as c11 left join c1 as c22 on c11.v1=c22.v1 group by ROLLUP(c11.v1,c11.v2);
 sum 
-----
  11
  11
  12
  12
  13
  13
  14
  14
  15
  15
  16
  16
  17
  17
  18
  18
  19
  19
  20
  20
 155
(21 rows)

explain verbose with c1 as (select v1, v2, v3 from t1) select sum(c11.v2) from c1 as c11 left join c1 as c22 on c11.v1=c22.v1 group by ROLLUP(c11.v2,c11.v3);
                                                         QUERY PLAN                                                         
----------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..2586.00 rows=21 width=8)
   Output: (sum(share1_ref2.v2))
   ->  Sequence  (cost=0.00..2586.00 rows=7 width=8)
         Output: (sum(share1_ref2.v2))
         ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=1)
               Output: share0_ref1.v1, share0_ref1.v2, share0_ref1.v3
               ->  Seq Scan on cte_prune.t1  (cost=0.00..431.00 rows=4 width=12)
                     Output: t1.v1, t1.v2, t1.v3
         ->  Sequence  (cost=0.00..2155.00 rows=7 width=8)
               Output: (sum(share1_ref2.v2))
               ->  Shared Scan (share slice:id 1:1)  (cost=0.00..862.00 rows=4 width=1)
                     Output: share1_ref1.v2, share1_ref1.v3
                     ->  Hash Left Join  (cost=0.00..862.00 rows=4 width=8)
                           Output: share0_ref3.v2, share0_ref3.v3
                           Hash Cond: (share0_ref3.v1 = share0_ref2.v1)
                           ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=12)
                                 Output: share0_ref3.v1, share0_ref3.v2, share0_ref3.v3
                           ->  Hash  (cost=431.00..431.00 rows=4 width=4)
                                 Output: share0_ref2.v1, share0_ref2.v2, share0_ref2.v3
                                 ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=4)
                                       Output: share0_ref2.v1, share0_ref2.v2, share0_ref2.v3
               ->  Append  (cost=0.00..1293.00 rows=7 width=8)
                     ->  GroupAggregate  (cost=0.00..431.00 rows=4 width=8)
                           Output: sum(share1_ref2.v2)
                           Group Key: share1_ref2.v2, share1_ref2.v3
                           ->  Sort  (cost=0.00..431.00 rows=4 width=8)
                                 Output: share1_ref2.v2, share1_ref2.v3
                                 Sort Key: share1_ref2.v2, share1_ref2.v3
                                 ->  Redistribute Motion 3:3  (slice2; segments: 3)  (cost=0.00..431.00 rows=4 width=8)
                                       Output: share1_ref2.v2, share1_ref2.v3
                                       Hash Key: share1_ref2.v2, share1_ref2.v3
                                       ->  Shared Scan (share slice:id 2:1)  (cost=0.00..431.00 rows=4 width=8)
                                             Output: share1_ref2.v2, share1_ref2.v3
                     ->  GroupAggregate  (cost=0.00..431.00 rows=4 width=8)
                           Output: sum(share1_ref3.v2)
                           Group Key: share1_ref3.v2
                           ->  Sort  (cost=0.00..431.00 rows=4 width=4)
                                 Output: share1_ref3.v2
                                 Sort Key: share1_ref3.v2
                                 ->  Redistribute Motion 3:3  (slice3; segments: 3)  (cost=0.00..431.00 rows=4 width=4)
                                       Output: share1_ref3.v2
                                       Hash Key: share1_ref3.v2
                                       ->  Result  (cost=0.00..431.00 rows=4 width=4)
                                             Output: share1_ref3.v2
                                             ->  Shared Scan (share slice:id 3:1)  (cost=0.00..431.00 rows=4 width=4)
                                                   Output: share1_ref3.v2, share1_ref3.v3
                     ->  Result  (cost=0.00..431.00 rows=1 width=8)
                           Output: (sum(share1_ref4.v2))
                           ->  Redistribute Motion 1:3  (slice4)  (cost=0.00..431.00 rows=1 width=8)
                                 Output: (sum(share1_ref4.v2))
                                 ->  Finalize Aggregate  (cost=0.00..431.00 rows=1 width=8)
                                       Output: sum(share1_ref4.v2)
                                       ->  Gather Motion 3:1  (slice5; segments: 3)  (cost=0.00..431.00 rows=1 width=8)
                                             Output: (PARTIAL sum(share1_ref4.v2))
                                             ->  Partial Aggregate  (cost=0.00..431.00 rows=1 width=8)
                                                   Output: PARTIAL sum(share1_ref4.v2)
                                                   ->  Shared Scan (share slice:id 5:1)  (cost=0.00..431.00 rows=4 width=4)
                                                         Output: share1_ref4.v2, share1_ref4.v3
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(60 rows)

with c1 as (select v1, v2, v3 from t1) select sum(c11.v2) OVER (ORDER BY c11.v3) from c1 as c11 left join c1 as c22 on c11.v1=c22.v1;
 sum 
-----
  11
  23
  36
  50
  65
  81
  98
 116
 135
 155
(10 rows)

-- CTE producer should have right output
explain verbose with c1 as (select t1.v1 as v1, t2.v1 as t21, t2.v2 as t22, t2.v3 as t23 from t1 join t2 on t1.v1 = t2.v1) 
select c11.v1 from c1 as c11 left join c1 as c22 on c11.v1=c22.v1;
                                          QUERY PLAN                                          
----------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..1724.00 rows=2 width=4)
   Output: share0_ref3.v1
   ->  Sequence  (cost=0.00..1724.00 rows=1 width=4)
         Output: share0_ref3.v1
         ->  Shared Scan (share slice:id 1:0)  (cost=0.00..862.00 rows=1 width=1)
               Output: share0_ref1.v1
               ->  Hash Join  (cost=0.00..862.00 rows=1 width=4)
                     Output: t1.v1
                     Hash Cond: (t1.v1 = t2.v1)
                     ->  Seq Scan on cte_prune.t1  (cost=0.00..431.00 rows=4 width=4)
                           Output: t1.v1
                     ->  Hash  (cost=431.00..431.00 rows=1 width=4)
                           Output: t2.v1
                           ->  Seq Scan on cte_prune.t2  (cost=0.00..431.00 rows=1 width=4)
                                 Output: t2.v1
         ->  Hash Left Join  (cost=0.00..862.00 rows=1 width=4)
               Output: share0_ref3.v1
               Hash Cond: (share0_ref3.v1 = share0_ref2.v1)
               ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=1 width=4)
                     Output: share0_ref3.v1
               ->  Hash  (cost=431.00..431.00 rows=1 width=4)
                     Output: share0_ref2.v1
                     ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=1 width=4)
                           Output: share0_ref2.v1
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(26 rows)

with c1 as (select t1.v1 as v1, t2.v1 as t21, t2.v2 as t22, t2.v3 as t23 from t1 join t2 on t1.v1 = t2.v1) 
select c11.v1 from c1 as c11 left join c1 as c22 on c11.v1=c22.v1;
 v1 
----
  5
  6
  9
 10
  2
  3
  4
  7
  8
  1
(10 rows)

explain verbose with c1 as (select sum(v1) as v1, sum(v2) as v2, v3 from t1 group by v3) 
select c11.v1 from c1 as c11 left join c1 as c22 on c11.v1=c22.v1;
                                                    QUERY PLAN                                                     
-------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..1293.00 rows=11 width=8)
   Output: share0_ref3.v1
   ->  Sequence  (cost=0.00..1293.00 rows=4 width=8)
         Output: share0_ref3.v1
         ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=1)
               Output: share0_ref1.v1
               ->  Redistribute Motion 3:3  (slice2; segments: 3)  (cost=0.00..431.00 rows=4 width=8)
                     Output: (sum(t1.v1))
                     Hash Key: (sum(t1.v1))
                     ->  HashAggregate  (cost=0.00..431.00 rows=4 width=8)
                           Output: sum(t1.v1)
                           Group Key: t1.v3
                           ->  Redistribute Motion 3:3  (slice3; segments: 3)  (cost=0.00..431.00 rows=4 width=12)
                                 Output: t1.v1, t1.v2, t1.v3
                                 Hash Key: t1.v3
                                 ->  Seq Scan on cte_prune.t1  (cost=0.00..431.00 rows=4 width=12)
                                       Output: t1.v1, t1.v2, t1.v3
         ->  Hash Left Join  (cost=0.00..862.00 rows=4 width=8)
               Output: share0_ref3.v1
               Hash Cond: (share0_ref3.v1 = share0_ref2.v1)
               ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=8)
                     Output: share0_ref3.v1
               ->  Hash  (cost=431.00..431.00 rows=4 width=8)
                     Output: share0_ref2.v1
                     ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=4 width=8)
                           Output: share0_ref2.v1
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(28 rows)

with c1 as (select lt1.v3 as v3, lt1.v1 as lo1, rt1.v1 as ro1 from t1 lt1, t1 rt1 where lt1.v2 = rt1.v2 and lt1.v1 = rt1.v1)  
select * from t1 where  t1.v1 in (select v3 from c1) and t1.v1 in (select v3 from c1 where v3 > 0);
 v1 | v2 | v3 
----+----+----
(0 rows)

-- TPCDS case
create table tpcds_store_sales
(
    ss_sold_date_sk           integer                       ,
    ss_sold_time_sk           integer                       ,
    ss_item_sk                integer               not null,
    ss_customer_sk            integer                       ,
    ss_cdemo_sk               integer                       ,
    ss_hdemo_sk               integer                       ,
    ss_addr_sk                integer                       ,
    ss_store_sk               integer                       ,
    ss_promo_sk               integer                       ,
    ss_ticket_number          integer               not null,
    ss_quantity               integer                       ,
    ss_wholesale_cost         decimal(7,2)                  ,
    ss_list_price             decimal(7,2)                  ,
    ss_sales_price            decimal(7,2)                  ,
    ss_ext_discount_amt       decimal(7,2)                  ,
    ss_ext_sales_price        decimal(7,2)                  ,
    ss_ext_wholesale_cost     decimal(7,2)                  ,
    ss_ext_list_price         decimal(7,2)                  ,
    ss_ext_tax                decimal(7,2)                  ,
    ss_coupon_amt             decimal(7,2)                  ,
    ss_net_paid               decimal(7,2)                  ,
    ss_net_paid_inc_tax       decimal(7,2)                  ,
    ss_net_profit             decimal(7,2)                  ,
    primary key (ss_item_sk, ss_ticket_number)
);
create table tpcds_date_dim
(
    d_date_sk                 integer               not null,
    d_date_id                 char(16)              not null,
    d_date                    date                          ,
    d_month_seq               integer                       ,
    d_week_seq                integer                       ,
    d_quarter_seq             integer                       ,
    d_year                    integer                       ,
    d_dow                     integer                       ,
    d_moy                     integer                       ,
    d_dom                     integer                       ,
    d_qoy                     integer                       ,
    d_fy_year                 integer                       ,
    d_fy_quarter_seq          integer                       ,
    d_fy_week_seq             integer                       ,
    d_day_name                char(9)                       ,
    d_quarter_name            char(6)                       ,
    d_holiday                 char(1)                       ,
    d_weekend                 char(1)                       ,
    d_following_holiday       char(1)                       ,
    d_first_dom               integer                       ,
    d_last_dom                integer                       ,
    d_same_day_ly             integer                       ,
    d_same_day_lq             integer                       ,
    d_current_day             char(1)                       ,
    d_current_week            char(1)                       ,
    d_current_month           char(1)                       ,
    d_current_quarter         char(1)                       ,
    d_current_year            char(1)                       ,
    primary key (d_date_sk)
);
create table tpcds_item
(
    i_item_sk                 integer               not null,
    i_item_id                 char(16)              not null,
    i_rec_start_date          date                          ,
    i_rec_end_date            date                          ,
    i_item_desc               varchar(200)                  ,
    i_current_price           decimal(7,2)                  ,
    i_wholesale_cost          decimal(7,2)                  ,
    i_brand_id                integer                       ,
    i_brand                   char(50)                      ,
    i_class_id                integer                       ,
    i_class                   char(50)                      ,
    i_category_id             integer                       ,
    i_category                char(50)                      ,
    i_manufact_id             integer                       ,
    i_manufact                char(50)                      ,
    i_size                    char(20)                      ,
    i_formulation             char(20)                      ,
    i_color                   char(20)                      ,
    i_units                   char(10)                      ,
    i_container               char(10)                      ,
    i_manager_id              integer                       ,
    i_product_name            char(50)                      ,
    primary key (i_item_sk)
);
create table tpcds_web_sales
(
    ws_sold_date_sk           integer                       ,
    ws_sold_time_sk           integer                       ,
    ws_ship_date_sk           integer                       ,
    ws_item_sk                integer               not null,
    ws_bill_customer_sk       integer                       ,
    ws_bill_cdemo_sk          integer                       ,
    ws_bill_hdemo_sk          integer                       ,
    ws_bill_addr_sk           integer                       ,
    ws_ship_customer_sk       integer                       ,
    ws_ship_cdemo_sk          integer                       ,
    ws_ship_hdemo_sk          integer                       ,
    ws_ship_addr_sk           integer                       ,
    ws_web_page_sk            integer                       ,
    ws_web_site_sk            integer                       ,
    ws_ship_mode_sk           integer                       ,
    ws_warehouse_sk           integer                       ,
    ws_promo_sk               integer                       ,
    ws_order_number           integer               not null,
    ws_quantity               integer                       ,
    ws_wholesale_cost         decimal(7,2)                  ,
    ws_list_price             decimal(7,2)                  ,
    ws_sales_price            decimal(7,2)                  ,
    ws_ext_discount_amt       decimal(7,2)                  ,
    ws_ext_sales_price        decimal(7,2)                  ,
    ws_ext_wholesale_cost     decimal(7,2)                  ,
    ws_ext_list_price         decimal(7,2)                  ,
    ws_ext_tax                decimal(7,2)                  ,
    ws_coupon_amt             decimal(7,2)                  ,
    ws_ext_ship_cost          decimal(7,2)                  ,
    ws_net_paid               decimal(7,2)                  ,
    ws_net_paid_inc_tax       decimal(7,2)                  ,
    ws_net_paid_inc_ship      decimal(7,2)                  ,
    ws_net_paid_inc_ship_tax  decimal(7,2)                  ,
    ws_net_profit             decimal(7,2)                  ,
primary key (ws_item_sk, ws_order_number)
);
-- sql 23
explain verbose with frequent_ss_items as 
 (select substr(i_item_desc,1,30) itemdesc,i_item_sk item_sk,d_date solddate,count(*) cnt
  from tpcds_store_sales
      ,tpcds_date_dim 
      ,tpcds_item
  where ss_sold_date_sk = d_date_sk
    and ss_item_sk = i_item_sk 
    and d_year in (1999,1999+1,1999+2,1999+3)
  group by substr(i_item_desc,1,30),i_item_sk,d_date
  having count(*) >4)
select t1.v1 from t1 where t1.v1 in (select item_sk from frequent_ss_items where true)
    and t1.v1 in (select item_sk from frequent_ss_items where item_sk > 0);
                                                                        QUERY PLAN                                                                        
----------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..2161.00 rows=1 width=4)
   Output: t1.v1
   ->  Sequence  (cost=0.00..2161.00 rows=1 width=4)
         Output: t1.v1
         ->  Shared Scan (share slice:id 1:0)  (cost=0.00..868.00 rows=1 width=1)
               Output: share0_ref1.i_item_sk
               ->  Result  (cost=0.00..868.00 rows=1 width=4)
                     Output: tpcds_item.i_item_sk
                     Filter: ((count(*)) > 4)
                     ->  HashAggregate  (cost=0.00..868.00 rows=1 width=12)
                           Output: count(*), count(*), tpcds_item.i_item_sk, (substr((tpcds_item.i_item_desc)::text, 1, 30)), tpcds_date_dim.d_date
                           Group Key: substr((tpcds_item.i_item_desc)::text, 1, 30), tpcds_item.i_item_sk, tpcds_date_dim.d_date
                           ->  Hash Join  (cost=0.00..868.00 rows=1 width=16)
                                 Output: substr((tpcds_item.i_item_desc)::text, 1, 30), tpcds_date_dim.d_date, tpcds_item.i_item_sk
                                 Hash Cond: (tpcds_item.i_item_sk = tpcds_store_sales.ss_item_sk)
                                 ->  Seq Scan on cte_prune.tpcds_item  (cost=0.00..431.00 rows=1 width=12)
                                       Output: tpcds_item.i_item_sk, tpcds_item.i_item_desc
                                 ->  Hash  (cost=437.00..437.00 rows=1 width=8)
                                       Output: tpcds_store_sales.ss_item_sk, tpcds_date_dim.d_date
                                       ->  Redistribute Motion 3:3  (slice2; segments: 3)  (cost=0.00..437.00 rows=1 width=8)
                                             Output: tpcds_store_sales.ss_item_sk, tpcds_date_dim.d_date
                                             Hash Key: tpcds_store_sales.ss_item_sk
                                             ->  Nested Loop  (cost=0.00..437.00 rows=1 width=8)
                                                   Output: tpcds_store_sales.ss_item_sk, tpcds_date_dim.d_date
                                                   Join Filter: true
                                                   ->  Redistribute Motion 3:3  (slice3; segments: 3)  (cost=0.00..431.00 rows=1 width=8)
                                                         Output: tpcds_store_sales.ss_sold_date_sk, tpcds_store_sales.ss_item_sk
                                                         Hash Key: tpcds_store_sales.ss_sold_date_sk
                                                         ->  Seq Scan on cte_prune.tpcds_store_sales  (cost=0.00..431.00 rows=1 width=8)
                                                               Output: tpcds_store_sales.ss_sold_date_sk, tpcds_store_sales.ss_item_sk
                                                   ->  Index Scan using tpcds_date_dim_pkey on cte_prune.tpcds_date_dim  (cost=0.00..6.00 rows=1 width=4)
                                                         Output: tpcds_date_dim.d_date, tpcds_date_dim.d_year
                                                         Index Cond: (tpcds_date_dim.d_date_sk = tpcds_store_sales.ss_sold_date_sk)
                                                         Filter: (tpcds_date_dim.d_year = ANY ('{1999,2000,2001,2002}'::integer[]))
         ->  Hash Semi Join  (cost=0.00..1293.00 rows=1 width=4)
               Output: t1.v1
               Hash Cond: (t1.v1 = share0_ref2.i_item_sk)
               ->  Hash Semi Join  (cost=0.00..862.00 rows=1 width=4)
                     Output: t1.v1
                     Hash Cond: (t1.v1 = share0_ref3.i_item_sk)
                     ->  Seq Scan on cte_prune.t1  (cost=0.00..431.00 rows=4 width=4)
                           Output: t1.v1
                     ->  Hash  (cost=431.00..431.00 rows=1 width=4)
                           Output: share0_ref3.i_item_sk
                           ->  Result  (cost=0.00..431.00 rows=1 width=4)
                                 Output: share0_ref3.i_item_sk
                                 Filter: (share0_ref3.i_item_sk > 0)
                                 ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=1 width=4)
                                       Output: share0_ref3.i_item_sk
               ->  Hash  (cost=431.00..431.00 rows=1 width=4)
                     Output: share0_ref2.i_item_sk
                     ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=1 width=4)
                           Output: share0_ref2.i_item_sk
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(55 rows)

-- sql 95
explain verbose with ws_wh as
(select ws1.ws_order_number,ws1.ws_warehouse_sk wh1,ws2.ws_warehouse_sk wh2
 from tpcds_web_sales ws1,tpcds_web_sales ws2
 where ws1.ws_order_number = ws2.ws_order_number
   and ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk)
select * from t1 where t1.v1 in (select ws_order_number from ws_wh where true) and t1.v1 in (select ws_order_number from ws_wh where ws_order_number > 0);
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..1730.00 rows=1 width=12)
   Output: t1.v1, t1.v2, t1.v3
   ->  Sequence  (cost=0.00..1730.00 rows=1 width=12)
         Output: t1.v1, t1.v2, t1.v3
         ->  Shared Scan (share slice:id 1:0)  (cost=0.00..437.00 rows=1 width=1)
               Output: share0_ref1.ws_order_number
               ->  Nested Loop  (cost=0.00..437.00 rows=1 width=4)
                     Output: ws1.ws_order_number
                     Join Filter: true
                     ->  Broadcast Motion 3:3  (slice2; segments: 3)  (cost=0.00..431.00 rows=1 width=8)
                           Output: ws1.ws_warehouse_sk, ws1.ws_order_number
                           ->  Seq Scan on cte_prune.tpcds_web_sales ws1  (cost=0.00..431.00 rows=1 width=8)
                                 Output: ws1.ws_warehouse_sk, ws1.ws_order_number
                     ->  Index Scan using tpcds_web_sales_pkey on cte_prune.tpcds_web_sales ws2  (cost=0.00..6.00 rows=1 width=1)
                           Output: ws2.ws_warehouse_sk
                           Index Cond: (ws2.ws_order_number = ws1.ws_order_number)
                           Filter: (ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk)
         ->  Hash Semi Join  (cost=0.00..1293.00 rows=1 width=12)
               Output: t1.v1, t1.v2, t1.v3
               Hash Cond: (t1.v1 = share0_ref2.ws_order_number)
               ->  Hash Semi Join  (cost=0.00..862.00 rows=1 width=12)
                     Output: t1.v1, t1.v2, t1.v3
                     Hash Cond: (t1.v1 = share0_ref3.ws_order_number)
                     ->  Seq Scan on cte_prune.t1  (cost=0.00..431.00 rows=4 width=12)
                           Output: t1.v1, t1.v2, t1.v3
                     ->  Hash  (cost=431.00..431.00 rows=1 width=4)
                           Output: share0_ref3.ws_order_number
                           ->  Redistribute Motion 3:3  (slice3; segments: 3)  (cost=0.00..431.00 rows=1 width=4)
                                 Output: share0_ref3.ws_order_number
                                 Hash Key: share0_ref3.ws_order_number
                                 ->  Result  (cost=0.00..431.00 rows=1 width=4)
                                       Output: share0_ref3.ws_order_number
                                       Filter: (share0_ref3.ws_order_number > 0)
                                       ->  Shared Scan (share slice:id 3:0)  (cost=0.00..431.00 rows=1 width=4)
                                             Output: share0_ref3.ws_order_number
               ->  Hash  (cost=431.00..431.00 rows=1 width=4)
                     Output: share0_ref2.ws_order_number
                     ->  Redistribute Motion 3:3  (slice4; segments: 3)  (cost=0.00..431.00 rows=1 width=4)
                           Output: share0_ref2.ws_order_number
                           Hash Key: share0_ref2.ws_order_number
                           ->  Shared Scan (share slice:id 4:0)  (cost=0.00..431.00 rows=1 width=4)
                                 Output: share0_ref2.ws_order_number
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(44 rows)

explain verbose with ws_wh as
(select ws1.ws_order_number,ws1.ws_warehouse_sk wh1,ws2.ws_warehouse_sk wh2
 from tpcds_web_sales ws1,tpcds_web_sales ws2
 where ws1.ws_order_number = ws2.ws_order_number
   and ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk)
select * from t1 where t1.v1 in (select wh1 from ws_wh where true) and t1.v1 in (select wh1 from ws_wh where ws_order_number > 0);
                                                            QUERY PLAN                                                            
----------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..1730.00 rows=1 width=12)
   Output: t1.v1, t1.v2, t1.v3
   ->  Sequence  (cost=0.00..1730.00 rows=1 width=12)
         Output: t1.v1, t1.v2, t1.v3
         ->  Shared Scan (share slice:id 1:0)  (cost=0.00..437.00 rows=1 width=1)
               Output: share0_ref1.ws_order_number, share0_ref1.ws_warehouse_sk
               ->  Nested Loop  (cost=0.00..437.00 rows=1 width=8)
                     Output: ws1.ws_order_number, ws1.ws_warehouse_sk
                     Join Filter: true
                     ->  Broadcast Motion 3:3  (slice2; segments: 3)  (cost=0.00..431.00 rows=1 width=8)
                           Output: ws1.ws_warehouse_sk, ws1.ws_order_number
                           ->  Seq Scan on cte_prune.tpcds_web_sales ws1  (cost=0.00..431.00 rows=1 width=8)
                                 Output: ws1.ws_warehouse_sk, ws1.ws_order_number
                     ->  Index Scan using tpcds_web_sales_pkey on cte_prune.tpcds_web_sales ws2  (cost=0.00..6.00 rows=1 width=1)
                           Output: ws2.ws_warehouse_sk
                           Index Cond: (ws2.ws_order_number = ws1.ws_order_number)
                           Filter: (ws1.ws_warehouse_sk <> ws2.ws_warehouse_sk)
         ->  Hash Semi Join  (cost=0.00..1293.00 rows=1 width=12)
               Output: t1.v1, t1.v2, t1.v3
               Hash Cond: (t1.v1 = share0_ref2.ws_warehouse_sk)
               ->  Hash Semi Join  (cost=0.00..862.00 rows=1 width=12)
                     Output: t1.v1, t1.v2, t1.v3
                     Hash Cond: (t1.v1 = share0_ref3.ws_warehouse_sk)
                     ->  Seq Scan on cte_prune.t1  (cost=0.00..431.00 rows=4 width=12)
                           Output: t1.v1, t1.v2, t1.v3
                     ->  Hash  (cost=431.00..431.00 rows=1 width=4)
                           Output: share0_ref3.ws_warehouse_sk
                           ->  Redistribute Motion 3:3  (slice3; segments: 3)  (cost=0.00..431.00 rows=1 width=4)
                                 Output: share0_ref3.ws_warehouse_sk
                                 Hash Key: share0_ref3.ws_warehouse_sk
                                 ->  Result  (cost=0.00..431.00 rows=1 width=4)
                                       Output: share0_ref3.ws_warehouse_sk
                                       Filter: (share0_ref3.ws_order_number > 0)
                                       ->  Shared Scan (share slice:id 3:0)  (cost=0.00..431.00 rows=1 width=8)
                                             Output: share0_ref3.ws_order_number, share0_ref3.ws_warehouse_sk
               ->  Hash  (cost=431.00..431.00 rows=1 width=4)
                     Output: share0_ref2.ws_warehouse_sk
                     ->  Redistribute Motion 3:3  (slice4; segments: 3)  (cost=0.00..431.00 rows=1 width=4)
                           Output: share0_ref2.ws_warehouse_sk
                           Hash Key: share0_ref2.ws_warehouse_sk
                           ->  Result  (cost=0.00..431.00 rows=1 width=4)
                                 Output: share0_ref2.ws_warehouse_sk
                                 ->  Shared Scan (share slice:id 4:0)  (cost=0.00..431.00 rows=1 width=4)
                                       Output: share0_ref2.ws_order_number, share0_ref2.ws_warehouse_sk
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(46 rows)

-- start_ignore
drop table tpcds_store_sales;
drop table tpcds_date_dim;
drop table tpcds_item;
drop table tpcds_web_sales;
drop table t1;
drop table t2;
-- end_ignore
-- comm cases
CREATE TABLE t3 AS SELECT i as a, i+1 as b from generate_series(1,10)i;
CREATE TABLE t4 AS SELECT i as c, i+1 as d from generate_series(1,10)i;
-- Additional filtering conditions are added to the consumer.
-- This is caused by `PexprInferPredicates` in the ORCA preprocessor.
explain verbose WITH t(a,b,d) AS
(
  SELECT t3.a,t3.b,t4.d FROM t3,t4 WHERE t3.a = t4.d
)
SELECT cup.*, SUM(t.d) OVER(PARTITION BY t.b) FROM
  (
    SELECT t4.*, AVG(t.b) OVER(PARTITION BY t.a ORDER BY t.b desc) AS e FROM t,t4
  ) AS cup,
t WHERE cup.e < 10
GROUP BY cup.c,cup.d, cup.e ,t.d, t.b
ORDER BY 1,2,3,4
LIMIT 10;
                                                                                                QUERY PLAN                                                                                                 
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..1356692546.41 rows=1 width=24)
   Output: t4_1.c, t4_1.d, (avg(share0_ref3.b) OVER (?)), (sum(share0_ref2.d) OVER (?))
   Merge Key: t4_1.c, t4_1.d, (avg(share0_ref3.b) OVER (?)), (sum(share0_ref2.d) OVER (?))
   ->  Sort  (cost=0.00..1356692546.41 rows=1 width=24)
         Output: t4_1.c, t4_1.d, (avg(share0_ref3.b) OVER (?)), (sum(share0_ref2.d) OVER (?))
         Sort Key: t4_1.c, t4_1.d, (avg(share0_ref3.b) OVER (?)), (sum(share0_ref2.d) OVER (?))
         ->  Sequence  (cost=0.00..1356692546.41 rows=1 width=24)
               Output: t4_1.c, t4_1.d, (avg(share0_ref3.b) OVER (?)), (sum(share0_ref2.d) OVER (?))
               ->  Shared Scan (share slice:id 1:0)  (cost=0.00..862.00 rows=1 width=1)
                     Output: share0_ref1.a, share0_ref1.b, share0_ref1.d
                     ->  Hash Join  (cost=0.00..862.00 rows=1 width=12)
                           Output: t3.a, t3.b, t4.d
                           Hash Cond: (t3.a = t4.d)
                           ->  Seq Scan on cte_prune.t3  (cost=0.00..431.00 rows=1 width=8)
                                 Output: t3.a, t3.b
                           ->  Hash  (cost=431.00..431.00 rows=1 width=4)
                                 Output: t4.d
                                 ->  Broadcast Motion 3:3  (slice2; segments: 3)  (cost=0.00..431.00 rows=1 width=4)
                                       Output: t4.d
                                       ->  Seq Scan on cte_prune.t4  (cost=0.00..431.00 rows=1 width=4)
                                             Output: t4.d
               ->  Redistribute Motion 1:3  (slice3)  (cost=0.00..1356691684.41 rows=1 width=24)
                     Output: t4_1.c, t4_1.d, (avg(share0_ref3.b) OVER (?)), (sum(share0_ref2.d) OVER (?))
                     ->  Limit  (cost=0.00..1356691684.41 rows=1 width=24)
                           Output: t4_1.c, t4_1.d, (avg(share0_ref3.b) OVER (?)), (sum(share0_ref2.d) OVER (?))
                           ->  Gather Motion 3:1  (slice4; segments: 3)  (cost=0.00..1356691684.41 rows=1 width=24)
                                 Output: t4_1.c, t4_1.d, (avg(share0_ref3.b) OVER (?)), (sum(share0_ref2.d) OVER (?))
                                 Merge Key: t4_1.c, t4_1.d, (avg(share0_ref3.b) OVER (?)), (sum(share0_ref2.d) OVER (?))
                                 ->  Result  (cost=0.00..1356691684.41 rows=1 width=24)
                                       Output: t4_1.c, t4_1.d, (avg(share0_ref3.b) OVER (?)), (sum(share0_ref2.d) OVER (?))
                                       ->  Sort  (cost=0.00..1356691684.41 rows=1 width=24)
                                             Output: t4_1.c, t4_1.d, (avg(share0_ref3.b) OVER (?)), (sum(share0_ref2.d) OVER (?)), share0_ref2.b
                                             Sort Key: t4_1.c, t4_1.d, (avg(share0_ref3.b) OVER (?)), (sum(share0_ref2.d) OVER (?))
                                             ->  WindowAgg  (cost=0.00..1356691684.40 rows=1 width=24)
                                                   Output: t4_1.c, t4_1.d, (avg(share0_ref3.b) OVER (?)), sum(share0_ref2.d) OVER (?), share0_ref2.b
                                                   Partition By: share0_ref2.b
                                                   ->  Sort  (cost=0.00..1356691684.40 rows=1 width=24)
                                                         Output: t4_1.c, t4_1.d, (avg(share0_ref3.b) OVER (?)), share0_ref2.b, share0_ref2.d
                                                         Sort Key: share0_ref2.b
                                                         ->  Redistribute Motion 3:3  (slice5; segments: 3)  (cost=0.00..1356691684.40 rows=1 width=24)
                                                               Output: t4_1.c, t4_1.d, (avg(share0_ref3.b) OVER (?)), share0_ref2.b, share0_ref2.d
                                                               Hash Key: share0_ref2.b
                                                               ->  GroupAggregate  (cost=0.00..1356691684.40 rows=1 width=24)
                                                                     Output: t4_1.c, t4_1.d, (avg(share0_ref3.b) OVER (?)), share0_ref2.b, share0_ref2.d
                                                                     Group Key: t4_1.c, t4_1.d, (avg(share0_ref3.b) OVER (?)), share0_ref2.d, share0_ref2.b
                                                                     ->  Sort  (cost=0.00..1356691684.40 rows=1 width=24)
                                                                           Output: t4_1.c, t4_1.d, (avg(share0_ref3.b) OVER (?)), share0_ref2.b, share0_ref2.d
                                                                           Sort Key: t4_1.c, t4_1.d, (avg(share0_ref3.b) OVER (?)), share0_ref2.d, share0_ref2.b
                                                                           ->  Redistribute Motion 3:3  (slice6; segments: 3)  (cost=0.00..1356691684.40 rows=1 width=24)
                                                                                 Output: t4_1.c, t4_1.d, (avg(share0_ref3.b) OVER (?)), share0_ref2.b, share0_ref2.d
                                                                                 Hash Key: t4_1.c, t4_1.d, (avg(share0_ref3.b) OVER (?)), share0_ref2.d, share0_ref2.b
                                                                                 ->  Nested Loop  (cost=0.00..1356691684.40 rows=1 width=24)
                                                                                       Output: t4_1.c, t4_1.d, (avg(share0_ref3.b) OVER (?)), share0_ref2.b, share0_ref2.d
                                                                                       Join Filter: true
                                                                                       ->  Result  (cost=0.00..1324032.22 rows=1 width=16)
                                                                                             Output: t4_1.c, t4_1.d, (avg(share0_ref3.b) OVER (?))
                                                                                             Filter: ((avg(share0_ref3.b) OVER (?)) < '10'::numeric)
                                                                                             ->  WindowAgg  (cost=0.00..1324032.22 rows=1 width=16)
                                                                                                   Output: avg(share0_ref3.b) OVER (?), share0_ref3.a, share0_ref3.b, t4_1.c, t4_1.d
                                                                                                   Partition By: share0_ref3.a
                                                                                                   Order By: share0_ref3.b
                                                                                                   ->  Sort  (cost=0.00..1324032.22 rows=1 width=16)
                                                                                                         Output: share0_ref3.a, share0_ref3.b, t4_1.c, t4_1.d
                                                                                                         Sort Key: share0_ref3.a, share0_ref3.b DESC
                                                                                                         ->  Redistribute Motion 3:3  (slice8; segments: 3)  (cost=0.00..1324032.22 rows=1 width=16)
                                                                                                               Output: share0_ref3.a, share0_ref3.b, t4_1.c, t4_1.d
                                                                                                               Hash Key: share0_ref3.a
                                                                                                               ->  Nested Loop  (cost=0.00..1324032.22 rows=1 width=16)
                                                                                                                     Output: share0_ref3.a, share0_ref3.b, t4_1.c, t4_1.d
                                                                                                                     Join Filter: true
                                                                                                                     ->  Broadcast Motion 3:3  (slice9; segments: 3)  (cost=0.00..431.00 rows=1 width=8)
                                                                                                                           Output: share0_ref3.a, share0_ref3.b
                                                                                                                           ->  Result  (cost=0.00..431.00 rows=1 width=8)
                                                                                                                                 Output: share0_ref3.a, share0_ref3.b
                                                                                                                                 Filter: (share0_ref3.a = share0_ref3.d)
                                                                                                                                 ->  Shared Scan (share slice:id 9:0)  (cost=0.00..431.00 rows=1 width=12)
                                                                                                                                       Output: share0_ref3.a, share0_ref3.b, share0_ref3.d
                                                                                                                     ->  Seq Scan on cte_prune.t4 t4_1  (cost=0.00..431.00 rows=1 width=8)
                                                                                                                           Output: t4_1.c, t4_1.d
                                                                                       ->  Materialize  (cost=0.00..431.00 rows=1 width=8)
                                                                                             Output: share0_ref2.b, share0_ref2.d
                                                                                             ->  Broadcast Motion 3:3  (slice7; segments: 3)  (cost=0.00..431.00 rows=1 width=8)
                                                                                                   Output: share0_ref2.b, share0_ref2.d
                                                                                                   ->  Result  (cost=0.00..431.00 rows=1 width=8)
                                                                                                         Output: share0_ref2.b, share0_ref2.d
                                                                                                         Filter: (share0_ref2.a = share0_ref2.d)
                                                                                                         ->  Shared Scan (share slice:id 7:0)  (cost=0.00..431.00 rows=1 width=12)
                                                                                                               Output: share0_ref2.a, share0_ref2.b, share0_ref2.d
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(90 rows)

WITH t(a,b,d) AS
(
  SELECT t3.a,t3.b,t4.d FROM t3,t4 WHERE t3.a = t4.d
)
SELECT cup.*, SUM(t.d) OVER(PARTITION BY t.b) FROM
  (
    SELECT t4.*, AVG(t.b) OVER(PARTITION BY t.a ORDER BY t.b desc) AS e FROM t,t4
  ) AS cup,
t WHERE cup.e < 10
GROUP BY cup.c,cup.d, cup.e ,t.d, t.b
ORDER BY 1,2,3,4
LIMIT 10;
 c | d |         e          | sum 
---+---+--------------------+-----
 1 | 2 | 3.0000000000000000 | 140
 1 | 2 | 3.0000000000000000 | 210
 1 | 2 | 3.0000000000000000 | 280
 1 | 2 | 3.0000000000000000 | 350
 1 | 2 | 3.0000000000000000 | 420
 1 | 2 | 3.0000000000000000 | 490
 1 | 2 | 3.0000000000000000 | 560
 1 | 2 | 3.0000000000000000 | 630
 1 | 2 | 3.0000000000000000 | 700
 1 | 2 | 4.0000000000000000 | 140
(10 rows)

-- grouping set will generate the internal CTE.
CREATE TABLE cte_prune_tenk1 (unique1 int4, unique2 int4, two int4, four int4, ten int4, twenty int4, hundred int4, thousand int4, twothousand int4, fivethous int4, tenthous int4, odd int4, even int4, stringu1 name, stringu2 name, string4 name);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'unique1' as the Apache Cloudberry data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO cte_prune_tenk1
SELECT
  i AS unique1,
  (i + 10000) AS unique2,
  i % 2 AS two,
  i % 4 AS four,
  i % 10 AS ten,
  i % 20 AS twenty,
  i % 100 AS hundred,
  i % 1000 AS thousand,
  i % 2000 AS twothousand,
  i % 5000 AS fivethous,
  i % 10000 AS tenthous,
  (2 * i + 1) AS odd,
  (2 * i) AS even,
  ('A' || lpad(i::text, 4, '0'))::name AS stringu1,
  ('B' || lpad(i::text, 4, '0'))::name AS stringu2,
  (CASE (i % 4)
    WHEN 0 THEN 'AAAA'::name
    WHEN 1 THEN 'BBBB'::name
    WHEN 2 THEN 'CCCC'::name
    ELSE 'DDDD'::name
  END) AS string4
FROM generate_series(0, 99) AS i;
INFO:  GPORCA failed to produce a plan, falling back to Postgres-based planner
DETAIL:  Falling back to Postgres-based planner because GPORCA does not support the following feature: Non-default collation
explain verbose select four, x
  from (select four, ten, 'foo'::text as x from cte_prune_tenk1) as t
  group by grouping sets (four, x)
  having x = 'foo';
                                                    QUERY PLAN                                                    
------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..862.00 rows=1 width=12)
   Output: (NULL::integer), share0_ref2.x
   ->  Sequence  (cost=0.00..862.00 rows=1 width=12)
         Output: (NULL::integer), share0_ref2.x
         ->  Shared Scan (share slice:id 1:0)  (cost=0.00..431.00 rows=1 width=1)
               Output: share0_ref1.four, share0_ref1.x
               ->  Seq Scan on cte_prune.cte_prune_tenk1  (cost=0.00..431.00 rows=1 width=4)
                     Output: cte_prune_tenk1.four, 'foo'::text
         ->  Append  (cost=0.00..431.00 rows=1 width=12)
               ->  GroupAggregate  (cost=0.00..431.00 rows=1 width=8)
                     Output: NULL::integer, share0_ref2.x
                     Group Key: share0_ref2.x
                     ->  Sort  (cost=0.00..431.00 rows=1 width=8)
                           Output: share0_ref2.x
                           Sort Key: share0_ref2.x
                           ->  Redistribute Motion 3:3  (slice2; segments: 3)  (cost=0.00..431.00 rows=1 width=8)
                                 Output: share0_ref2.x
                                 Hash Key: share0_ref2.x
                                 ->  Result  (cost=0.00..431.00 rows=1 width=8)
                                       Output: share0_ref2.x
                                       Filter: (share0_ref2.x = 'foo'::text)
                                       ->  Shared Scan (share slice:id 2:0)  (cost=0.00..431.00 rows=1 width=8)
                                             Output: share0_ref2.four, share0_ref2.x
               ->  Result  (cost=0.00..0.00 rows=0 width=12)
                     Output: (NULL::integer), (NULL::text)
                     One-Time Filter: (gp_execution_segment() = 0)
                     ->  Result  (cost=0.00..0.00 rows=0 width=12)
                           Output: NULL::integer, NULL::text
                           One-Time Filter: false
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(31 rows)

select four, x
  from (select four, ten, 'foo'::text as x from cte_prune_tenk1) as t
  group by grouping sets (four, x)
  having x = 'foo';
 four |  x  
------+-----
      | foo
(1 row)

-- nest CTE cases
-- start_ignore
drop table city;
ERROR:  table "city" does not exist
drop table country;
ERROR:  table "country" does not exist
drop table countrylanguage;
ERROR:  table "countrylanguage" does not exist
-- end_ignore
CREATE TABLE city (
    id integer NOT NULL,
    name text NOT NULL,
    countrycode character(3) NOT NULL,
    district text NOT NULL,
    population integer NOT NULL
) distributed by(id);
CREATE TABLE country (
    code character(3) NOT NULL,
    name text NOT NULL,
    continent text NOT NULL,
    region text NOT NULL,
    surfacearea numeric(10,2) NOT NULL,
    indepyear smallint,
    population integer NOT NULL,
    lifeexpectancy real,
    gnp numeric(10,2),
    gnpold numeric(10,2),
    localname text NOT NULL,
    governmentform text NOT NULL,
    headofstate text,
    capital integer,
    code2 character(2) NOT NULL
) distributed by (code);
CREATE TABLE countrylanguage (
    countrycode character(3) NOT NULL,
    "language" text NOT NULL,
    isofficial boolean NOT NULL,
    percentage real NOT NULL
)distributed by (countrycode,language);
ALTER TABLE ONLY city
    ADD CONSTRAINT city_pkey PRIMARY KEY (id);
ALTER TABLE ONLY country
    ADD CONSTRAINT country_pkey PRIMARY KEY (code);
ALTER TABLE ONLY countrylanguage
    ADD CONSTRAINT countrylanguage_pkey PRIMARY KEY (countrycode, "language");
-- CTE1(inlined) in CTE2(no-inlined) case
explain verbose with country as
(select country.code,country.name COUNTRY, city.name CAPITAL, language, isofficial, percentage
 FROM country,city,countrylanguage
 WHERE country.code = countrylanguage.countrycode
 and country.capital = city.id
 and country.continent = 'Europe'),
countrylanguage as
(select country.code,country.COUNTRY,country.language,country.isofficial,country.percentage
 FROM country,countrylanguage
 WHERE country.code = countrylanguage.countrycode
)
select * from
(select * from country where isofficial='True') country,
(select * from countrylanguage where percentage > 50) countrylanguage
where country.percentage = countrylanguage.percentage order by countrylanguage.COUNTRY,country.language LIMIT 40;
                                                                                                                                         QUERY PLAN                                                                                                                                         
--------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..1736.01 rows=1 width=66)
   Output: share0_ref3.code, share0_ref3.name, share0_ref3.name_1, share0_ref3.language, share0_ref3.isofficial, share0_ref3.percentage, share0_ref2.code, share0_ref2.name, share0_ref2.language, share0_ref2.isofficial, share0_ref2.percentage
   Merge Key: share0_ref2.name, share0_ref3.language
   ->  Sort  (cost=0.00..1736.01 rows=1 width=66)
         Output: share0_ref3.code, share0_ref3.name, share0_ref3.name_1, share0_ref3.language, share0_ref3.isofficial, share0_ref3.percentage, share0_ref2.code, share0_ref2.name, share0_ref2.language, share0_ref2.isofficial, share0_ref2.percentage
         Sort Key: share0_ref2.name, share0_ref3.language
         ->  Sequence  (cost=0.00..1736.00 rows=1 width=66)
               Output: share0_ref3.code, share0_ref3.name, share0_ref3.name_1, share0_ref3.language, share0_ref3.isofficial, share0_ref3.percentage, share0_ref2.code, share0_ref2.name, share0_ref2.language, share0_ref2.isofficial, share0_ref2.percentage
               ->  Shared Scan (share slice:id 1:0)  (cost=0.00..868.00 rows=1 width=1)
                     Output: share0_ref1.code, share0_ref1.name, share0_ref1.name_1, share0_ref1.language, share0_ref1.isofficial, share0_ref1.percentage
                     ->  Hash Join  (cost=0.00..868.00 rows=1 width=37)
                           Output: country.code, country.name, city.name, countrylanguage.language, countrylanguage.isofficial, countrylanguage.percentage
                           Hash Cond: (country.capital = city.id)
                           ->  Redistribute Motion 3:3  (slice2; segments: 3)  (cost=0.00..437.00 rows=1 width=33)
                                 Output: country.code, country.name, country.capital, countrylanguage.language, countrylanguage.isofficial, countrylanguage.percentage
                                 Hash Key: country.capital
                                 ->  Nested Loop  (cost=0.00..437.00 rows=1 width=33)
                                       Output: country.code, country.name, country.capital, countrylanguage.language, countrylanguage.isofficial, countrylanguage.percentage
                                       Join Filter: true
                                       ->  Redistribute Motion 3:3  (slice3; segments: 3)  (cost=0.00..431.00 rows=1 width=21)
                                             Output: countrylanguage.countrycode, countrylanguage.language, countrylanguage.isofficial, countrylanguage.percentage
                                             Hash Key: countrylanguage.countrycode
                                             ->  Seq Scan on cte_prune.countrylanguage  (cost=0.00..431.00 rows=1 width=21)
                                                   Output: countrylanguage.countrycode, countrylanguage.language, countrylanguage.isofficial, countrylanguage.percentage
                                       ->  Index Scan using country_pkey on cte_prune.country  (cost=0.00..6.00 rows=1 width=20)
                                             Output: country.code, country.name, country.continent, country.capital
                                             Index Cond: (country.code = countrylanguage.countrycode)
                                             Filter: (country.continent = 'Europe'::text)
                           ->  Hash  (cost=431.00..431.00 rows=1 width=12)
                                 Output: city.id, city.name
                                 ->  Seq Scan on cte_prune.city  (cost=0.00..431.00 rows=1 width=12)
                                       Output: city.id, city.name
               ->  Redistribute Motion 1:3  (slice4)  (cost=0.00..868.00 rows=1 width=66)
                     Output: share0_ref3.code, share0_ref3.name, share0_ref3.name_1, share0_ref3.language, share0_ref3.isofficial, share0_ref3.percentage, share0_ref2.code, share0_ref2.name, share0_ref2.language, share0_ref2.isofficial, share0_ref2.percentage
                     ->  Limit  (cost=0.00..868.00 rows=1 width=66)
                           Output: share0_ref3.code, share0_ref3.name, share0_ref3.name_1, share0_ref3.language, share0_ref3.isofficial, share0_ref3.percentage, share0_ref2.code, share0_ref2.name, share0_ref2.language, share0_ref2.isofficial, share0_ref2.percentage
                           ->  Gather Motion 3:1  (slice5; segments: 3)  (cost=0.00..868.00 rows=1 width=66)
                                 Output: share0_ref3.code, share0_ref3.name, share0_ref3.name_1, share0_ref3.language, share0_ref3.isofficial, share0_ref3.percentage, share0_ref2.code, share0_ref2.name, share0_ref2.language, share0_ref2.isofficial, share0_ref2.percentage
                                 Merge Key: share0_ref2.name, share0_ref3.language
                                 ->  Sort  (cost=0.00..868.00 rows=1 width=66)
                                       Output: share0_ref3.code, share0_ref3.name, share0_ref3.name_1, share0_ref3.language, share0_ref3.isofficial, share0_ref3.percentage, share0_ref2.code, share0_ref2.name, share0_ref2.language, share0_ref2.isofficial, share0_ref2.percentage
                                       Sort Key: share0_ref2.name, share0_ref3.language
                                       ->  Hash Join  (cost=0.00..868.00 rows=1 width=66)
                                             Output: share0_ref3.code, share0_ref3.name, share0_ref3.name_1, share0_ref3.language, share0_ref3.isofficial, share0_ref3.percentage, share0_ref2.code, share0_ref2.name, share0_ref2.language, share0_ref2.isofficial, share0_ref2.percentage
                                             Hash Cond: (share0_ref3.percentage = share0_ref2.percentage)
                                             ->  Redistribute Motion 3:3  (slice6; segments: 3)  (cost=0.00..431.00 rows=1 width=37)
                                                   Output: share0_ref3.code, share0_ref3.name, share0_ref3.name_1, share0_ref3.language, share0_ref3.isofficial, share0_ref3.percentage
                                                   Hash Key: share0_ref3.percentage
                                                   ->  Result  (cost=0.00..431.00 rows=1 width=37)
                                                         Output: share0_ref3.code, share0_ref3.name, share0_ref3.name_1, share0_ref3.language, share0_ref3.isofficial, share0_ref3.percentage
                                                         Filter: (share0_ref3.isofficial AND (share0_ref3.percentage > '50'::double precision))
                                                         ->  Shared Scan (share slice:id 6:0)  (cost=0.00..431.00 rows=1 width=37)
                                                               Output: share0_ref3.code, share0_ref3.name, share0_ref3.name_1, share0_ref3.language, share0_ref3.isofficial, share0_ref3.percentage
                                             ->  Hash  (cost=437.00..437.00 rows=1 width=29)
                                                   Output: share0_ref2.code, share0_ref2.name, share0_ref2.language, share0_ref2.isofficial, share0_ref2.percentage
                                                   ->  Redistribute Motion 3:3  (slice7; segments: 3)  (cost=0.00..437.00 rows=1 width=29)
                                                         Output: share0_ref2.code, share0_ref2.name, share0_ref2.language, share0_ref2.isofficial, share0_ref2.percentage
                                                         Hash Key: share0_ref2.percentage
                                                         ->  Result  (cost=0.00..437.00 rows=1 width=29)
                                                               Output: share0_ref2.code, share0_ref2.name, share0_ref2.language, share0_ref2.isofficial, share0_ref2.percentage
                                                               Filter: (share0_ref2.percentage > '50'::double precision)
                                                               ->  Nested Loop  (cost=0.00..437.00 rows=1 width=29)
                                                                     Output: share0_ref2.code, share0_ref2.name, share0_ref2.language, share0_ref2.isofficial, share0_ref2.percentage
                                                                     Join Filter: true
                                                                     ->  Broadcast Motion 3:3  (slice8; segments: 3)  (cost=0.00..431.00 rows=1 width=29)
                                                                           Output: share0_ref2.code, share0_ref2.name, share0_ref2.language, share0_ref2.isofficial, share0_ref2.percentage
                                                                           ->  Result  (cost=0.00..431.00 rows=1 width=29)
                                                                                 Output: share0_ref2.code, share0_ref2.name, share0_ref2.language, share0_ref2.isofficial, share0_ref2.percentage
                                                                                 ->  Shared Scan (share slice:id 8:0)  (cost=0.00..431.00 rows=1 width=29)
                                                                                       Output: share0_ref2.code, share0_ref2.name, share0_ref2.name_1, share0_ref2.language, share0_ref2.isofficial, share0_ref2.percentage
                                                                     ->  Index Scan using countrylanguage_pkey on cte_prune.countrylanguage countrylanguage_1  (cost=0.00..6.00 rows=1 width=1)
                                                                           Index Cond: (countrylanguage_1.countrycode = share0_ref2.code)
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(74 rows)

-- CTE in the main query and subqueries within the main query
explain verbose with bad_headofstates as 
(
 select country.code,country.name,country.headofstate,countrylanguage.language
 from
 country,countrylanguage
 where country.code = countrylanguage.countrycode and countrylanguage.isofficial=true
 and (country.gnp < country.gnpold or country.gnp < 3000)
)
select OUTERMOST_FOO.*,bad_headofstates.headofstate from (
select avg(population),region from
(
select FOO.*,bad_headofstates.headofstate,city.name
from
(select bad_headofstates.code,country.capital,country.region,country.population from
bad_headofstates,country where bad_headofstates.code = country.code) FOO, bad_headofstates,city
where FOO.code = bad_headofstates.code and FOO.capital = city.id) OUTER_FOO
group by region ) OUTERMOST_FOO,bad_headofstates,country 
where country.code = bad_headofstates.code and country.region = OUTERMOST_FOO.region
order by OUTERMOST_FOO.region,bad_headofstates.headofstate LIMIT 40;
                                                                         QUERY PLAN                                                                          
-------------------------------------------------------------------------------------------------------------------------------------------------------------
 Sequence  (cost=0.00..1748.00 rows=1 width=24)
   Output: (avg(country_1.population)), country_1.region, share0_ref2.headofstate
   ->  Shared Scan (share slice:id 0:0)  (cost=0.00..437.00 rows=1 width=1)
         Output: share0_ref1.code, share0_ref1.headofstate
         ->  Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..437.00 rows=1 width=16)
               Output: country.code, country.headofstate
               ->  Nested Loop  (cost=0.00..437.00 rows=1 width=16)
                     Output: country.code, country.headofstate
                     Join Filter: true
                     ->  Redistribute Motion 3:3  (slice2; segments: 3)  (cost=0.00..431.00 rows=1 width=8)
                           Output: countrylanguage.countrycode
                           Hash Key: countrylanguage.countrycode
                           ->  Seq Scan on cte_prune.countrylanguage  (cost=0.00..431.00 rows=1 width=8)
                                 Output: countrylanguage.countrycode
                                 Filter: countrylanguage.isofficial
                     ->  Index Scan using country_pkey on cte_prune.country  (cost=0.00..6.00 rows=1 width=16)
                           Output: country.code, country.gnp, country.gnpold, country.headofstate
                           Index Cond: (country.code = countrylanguage.countrycode)
                           Filter: ((country.gnp < country.gnpold) OR (country.gnp < '3000'::numeric))
   ->  Limit  (cost=0.00..1311.00 rows=1 width=24)
         Output: (avg(country_1.population)), country_1.region, share0_ref2.headofstate
         ->  Sort  (cost=0.00..1311.00 rows=1 width=24)
               Output: (avg(country_1.population)), country_1.region, share0_ref2.headofstate
               Sort Key: country_1.region, share0_ref2.headofstate
               ->  Hash Join  (cost=0.00..1311.00 rows=1 width=24)
                     Output: (avg(country_1.population)), country_1.region, share0_ref2.headofstate
                     Hash Cond: (country_1.region = country_2.region)
                     ->  HashAggregate  (cost=0.00..874.00 rows=1 width=16)
                           Output: avg(country_1.population), country_1.region
                           Group Key: country_1.region
                           ->  Hash Join  (cost=0.00..874.00 rows=1 width=12)
                                 Output: country_1.region, country_1.population
                                 Hash Cond: (share0_ref4.code = share0_ref3.code)
                                 ->  Gather Motion 3:1  (slice3; segments: 3)  (cost=0.00..443.00 rows=1 width=20)
                                       Output: share0_ref4.code, country_1.region, country_1.population
                                       ->  Nested Loop  (cost=0.00..443.00 rows=1 width=20)
                                             Output: share0_ref4.code, country_1.region, country_1.population
                                             Join Filter: true
                                             ->  Redistribute Motion 3:3  (slice4; segments: 3)  (cost=0.00..437.00 rows=1 width=24)
                                                   Output: share0_ref4.code, country_1.region, country_1.population, country_1.capital
                                                   Hash Key: country_1.capital
                                                   ->  Nested Loop  (cost=0.00..437.00 rows=1 width=24)
                                                         Output: share0_ref4.code, country_1.region, country_1.population, country_1.capital
                                                         Join Filter: true
                                                         ->  Redistribute Motion 1:3  (slice5)  (cost=0.00..431.00 rows=1 width=8)
                                                               Output: share0_ref4.code
                                                               Hash Key: share0_ref4.code
                                                               ->  Result  (cost=0.00..431.00 rows=1 width=8)
                                                                     Output: share0_ref4.code
                                                                     ->  Shared Scan (share slice:id 5:0)  (cost=0.00..431.00 rows=1 width=8)
                                                                           Output: share0_ref4.code, share0_ref4.headofstate
                                                         ->  Index Scan using country_pkey on cte_prune.country country_1  (cost=0.00..6.00 rows=1 width=16)
                                                               Output: country_1.region, country_1.population, country_1.capital
                                                               Index Cond: (country_1.code = share0_ref4.code)
                                             ->  Index Scan using city_pkey on cte_prune.city  (cost=0.00..6.00 rows=1 width=1)
                                                   Index Cond: (city.id = country_1.capital)
                                 ->  Hash  (cost=431.00..431.00 rows=1 width=8)
                                       Output: share0_ref3.code, share0_ref3.headofstate
                                       ->  Shared Scan (share slice:id 0:0)  (cost=0.00..431.00 rows=1 width=8)
                                             Output: share0_ref3.code, share0_ref3.headofstate
                     ->  Hash  (cost=437.00..437.00 rows=1 width=16)
                           Output: share0_ref2.headofstate, country_2.region
                           ->  Gather Motion 3:1  (slice6; segments: 3)  (cost=0.00..437.00 rows=1 width=16)
                                 Output: share0_ref2.headofstate, country_2.region
                                 ->  Nested Loop  (cost=0.00..437.00 rows=1 width=16)
                                       Output: share0_ref2.headofstate, country_2.region
                                       Join Filter: true
                                       ->  Redistribute Motion 1:3  (slice7)  (cost=0.00..431.00 rows=1 width=16)
                                             Output: share0_ref2.code, share0_ref2.headofstate
                                             Hash Key: share0_ref2.code
                                             ->  Shared Scan (share slice:id 7:0)  (cost=0.00..431.00 rows=1 width=16)
                                                   Output: share0_ref2.code, share0_ref2.headofstate
                                       ->  Index Scan using country_pkey on cte_prune.country country_2  (cost=0.00..6.00 rows=1 width=8)
                                             Output: country_2.region
                                             Index Cond: (country_2.code = share0_ref2.code)
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(77 rows)

-- start_ignore
drop table city;
drop table country;
drop table countrylanguage;
-- end_ignore
-- inlined CTEs
CREATE TABLE t5 AS SELECT i as c, i+1 as d from generate_series(1,10)i;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'c' as the Apache Cloudberry data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
CREATE TABLE t6 AS SELECT i as a, i+1 as b from generate_series(1,10)i;
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column(s) named 'a' as the Apache Cloudberry data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
-- inlined CTEs should have not unused columns(ex. t5.*, t6.* in output)
explain verbose WITH w AS (SELECT a, b from t6 where b < 5)
SELECT *
FROM t6,
     (WITH v AS (SELECT c, d FROM t5, w WHERE c = w.a AND c < 2)
      SELECT v1.c, v1.d FROM v v1, v v2 WHERE v1.c = v2.c AND v1.d > 1
     ) x
WHERE t6.a = x.c ORDER BY 1;
                                                        QUERY PLAN                                                         
---------------------------------------------------------------------------------------------------------------------------
 Gather Motion 3:1  (slice1; segments: 3)  (cost=0.00..2155.00 rows=1 width=16)
   Output: t6_1.a, t6_1.b, share1_ref3.c, share1_ref3.d
   Merge Key: t6_1.a
   ->  Sort  (cost=0.00..2155.00 rows=1 width=16)
         Output: t6_1.a, t6_1.b, share1_ref3.c, share1_ref3.d
         Sort Key: t6_1.a
         ->  Hash Join  (cost=0.00..2155.00 rows=1 width=16)
               Output: t6_1.a, t6_1.b, share1_ref3.c, share1_ref3.d
               Hash Cond: (share1_ref3.c = t6_1.a)
               ->  Sequence  (cost=0.00..1724.00 rows=1 width=8)
                     Output: share1_ref3.c, share1_ref3.d
                     ->  Shared Scan (share slice:id 1:1)  (cost=0.00..862.00 rows=1 width=1)
                           Output: share1_ref1.c, share1_ref1.d
                           ->  Hash Join  (cost=0.00..862.00 rows=1 width=8)
                                 Output: t5.c, t5.d
                                 Hash Cond: (t5.c = t6.a)
                                 ->  Seq Scan on cte_prune.t5  (cost=0.00..431.00 rows=1 width=8)
                                       Output: t5.c, t5.d
                                       Filter: (t5.c < 2)
                                 ->  Hash  (cost=431.00..431.00 rows=1 width=4)
                                       Output: t6.a
                                       ->  Broadcast Motion 3:3  (slice2; segments: 3)  (cost=0.00..431.00 rows=1 width=4)
                                             Output: t6.a
                                             ->  Result  (cost=0.00..431.00 rows=1 width=4)
                                                   Output: t6.a
                                                   Filter: (t6.a < 2)
                                                   ->  Seq Scan on cte_prune.t6  (cost=0.00..431.00 rows=1 width=4)
                                                         Output: t6.a
                                                         Filter: (t6.b < 5)
                     ->  Hash Join  (cost=0.00..862.00 rows=1 width=8)
                           Output: share1_ref3.c, share1_ref3.d
                           Hash Cond: (share1_ref3.c = share1_ref2.c)
                           ->  Result  (cost=0.00..431.00 rows=1 width=8)
                                 Output: share1_ref3.c, share1_ref3.d
                                 Filter: ((share1_ref3.d > 1) AND (share1_ref3.c < 2))
                                 ->  Shared Scan (share slice:id 1:1)  (cost=0.00..431.00 rows=1 width=8)
                                       Output: share1_ref3.c, share1_ref3.d
                           ->  Hash  (cost=431.00..431.00 rows=1 width=4)
                                 Output: share1_ref2.c
                                 ->  Broadcast Motion 3:3  (slice3; segments: 3)  (cost=0.00..431.00 rows=1 width=4)
                                       Output: share1_ref2.c
                                       ->  Result  (cost=0.00..431.00 rows=1 width=4)
                                             Output: share1_ref2.c
                                             Filter: (share1_ref2.c < 2)
                                             ->  Shared Scan (share slice:id 3:1)  (cost=0.00..431.00 rows=1 width=4)
                                                   Output: share1_ref2.c, share1_ref2.d
               ->  Hash  (cost=431.00..431.00 rows=1 width=8)
                     Output: t6_1.a, t6_1.b
                     ->  Broadcast Motion 3:3  (slice4; segments: 3)  (cost=0.00..431.00 rows=1 width=8)
                           Output: t6_1.a, t6_1.b
                           ->  Seq Scan on cte_prune.t6 t6_1  (cost=0.00..431.00 rows=1 width=8)
                                 Output: t6_1.a, t6_1.b
                                 Filter: (t6_1.a < 2)
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(55 rows)

WITH w AS (SELECT a, b from t6 where b < 5)
SELECT *
FROM t6,
     (WITH v AS (SELECT c, d FROM t5, w WHERE c = w.a AND c < 2)
      SELECT v1.c, v1.d FROM v v1, v v2 WHERE v1.c = v2.c AND v1.d > 1
     ) x
WHERE t6.a = x.c ORDER BY 1;
 a | b | c | d 
---+---+---+---
 1 | 2 | 1 | 2
(1 row)

CREATE TABLE t7 (f1 integer, f2 integer, f3 float);
NOTICE:  Table doesn't have 'DISTRIBUTED BY' clause -- Using column named 'f1' as the Apache Cloudberry data distribution key for this table.
HINT:  The 'DISTRIBUTED BY' clause determines the distribution of data. Make sure column(s) chosen are the optimal data distribution key to minimize skew.
INSERT INTO t7 VALUES (1, 2, 3);
INSERT INTO t7 VALUES (2, 3, 4);
INSERT INTO t7 VALUES (3, 4, 5);
INSERT INTO t7 VALUES (1, 1, 1);
INSERT INTO t7 VALUES (2, 2, 2);
INSERT INTO t7 VALUES (3, 3, 3);
INSERT INTO t7 VALUES (6, 7, 8);
INSERT INTO t7 VALUES (8, 9, NULL);
-- inlined CTEs should used the origin cexpression with recreated
explain (verbose, costs off)
with x as (select * from (select f1 from t7) ss)
select * from x where f1 = 1;
                     QUERY PLAN                      
-----------------------------------------------------
 Gather Motion 1:1  (slice1; segments: 1)
   Output: f1
   ->  Seq Scan on cte_prune.t7
         Output: f1
         Filter: (t7.f1 = 1)
 Settings: enable_parallel = 'off', optimizer = 'on'
 Optimizer: GPORCA
(7 rows)

with x as (select * from (select f1 from t7) ss)
select * from x where f1 = 1;
 f1 
----
  1
  1
(2 rows)

-- start_ignore
drop table t5;
drop table t6;
drop table t7;
drop schema cte_prune cascade;
NOTICE:  drop cascades to 2 other objects
DETAIL:  drop cascades to table t3
drop cascades to table t4
-- end_ignore
